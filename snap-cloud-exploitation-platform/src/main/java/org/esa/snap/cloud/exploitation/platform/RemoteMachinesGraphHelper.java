package org.esa.snap.cloud.exploitation.platform;

import com.bc.ceres.binding.dom.DomElement;
import com.bc.ceres.binding.dom.XppDomElement;
import org.esa.snap.cloud.exploitation.platform.utils.FileUtils;
import org.esa.snap.cloud.exploitation.platform.utils.StringUtils;
import org.esa.snap.core.gpf.OperatorSpi;
import org.esa.snap.core.gpf.common.ReadOp;
import org.esa.snap.core.gpf.common.WriteOp;
import org.esa.snap.core.gpf.graph.Graph;
import org.esa.snap.core.gpf.graph.GraphException;
import org.esa.snap.core.gpf.graph.GraphIO;
import org.esa.snap.core.gpf.graph.Node;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Created by jcoravu on 10/1/2019.
 */
public class RemoteMachinesGraphHelper {

    private final File[] sourceProductFiles;
    private final List<Node> readOperatorNodes;
    private final Node writeOperatorNode;
    private final Graph graph;
    private final File graphFileForRemoteMachines;
    private final String masterSharedFolderURL;
    private final String localSharedFolderPath;
    private final Set<File> processedSourceProductFiles;
    private final List<String> outputProductsRelativeFilePath;
    private final Map<ServerCredentials, Set<File>> invalidRemoteMachine;
    private final boolean continueOnFailure;
    private final AtomicBoolean exceptionOccurred;

    private int sourceProductFilesIndex;

    public RemoteMachinesGraphHelper(String masterSharedFolderURL, String localSharedFolderPath, String graphFilePathForRemoteMachines,
                                     File[] sourceProductFiles, boolean continueOnFailure)
                                     throws IOException, GraphException {

        this.masterSharedFolderURL = masterSharedFolderURL;
        this.localSharedFolderPath = localSharedFolderPath;
        this.sourceProductFiles = sourceProductFiles;
        this.continueOnFailure = continueOnFailure;

        this.graphFileForRemoteMachines = new File(graphFilePathForRemoteMachines);
        this.exceptionOccurred = new AtomicBoolean(false);

        this.outputProductsRelativeFilePath = new ArrayList<String>();
        this.sourceProductFilesIndex = 0;

        this.processedSourceProductFiles = new HashSet<File>();
        this.invalidRemoteMachine = new HashMap<ServerCredentials, Set<File>>();

        this.graph = readGraph(this.graphFileForRemoteMachines);

        this.readOperatorNodes = new ArrayList<Node>();
        List<Node> writeOperatorNodes = new ArrayList<Node>();
        for (int i = 0; i < this.graph.getNodeCount(); i++) {
            Node node = this.graph.getNode(i);
            if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(WriteOp.class))) {
                configureGraphWriteNode(node);
                writeOperatorNodes.add(node);
            } else if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(ReadOp.class))) {
                configureGraphReadNode(node);
                this.readOperatorNodes.add(node);
            }
        }
        if (writeOperatorNodes.size() == 0) {
            throw new IllegalStateException("The slave graph must contain the write operator.");
        }
        if (writeOperatorNodes.size() > 1) {
            throw new IllegalStateException("The slave graph must contain only one write operator. The actual number is " + writeOperatorNodes.size() + ".");
        }
        if (this.readOperatorNodes.size() == 0) {
            throw new IllegalStateException("The slave graph must contain at least one read operator. The read operator count must be equal with the source product count.");
        }
        if (this.sourceProductFiles.length % this.readOperatorNodes.size() != 0) {
            throw new IllegalStateException("The source product file count "+this.sourceProductFiles.length+" must be multiple of the graph read operator count "+this.readOperatorNodes.size()+".");
        }

        this.writeOperatorNode = writeOperatorNodes.get(0);
    }

    public String getMasterSharedFolderURL() {
        return masterSharedFolderURL;
    }

    public String getLocalSharedFolderPath() {
        return localSharedFolderPath;
    }

    public void setExceptionOccurredOnRemoteMachine(Exception exception) {
        synchronized (this.exceptionOccurred) {
            this.exceptionOccurred.set(true);
        }
    }

    private boolean isExceptionOccurredOnRemoteMachine() {
        synchronized (this.exceptionOccurred) {
            return this.exceptionOccurred.get();
        }
    }

    public boolean canContinueIfExceptionOccurredOnRemoteMachines() {
        if (isExceptionOccurredOnRemoteMachine()) {
            return this.continueOnFailure;
        }
        return true;
    }

    public synchronized void revalidateUnprocessedGraphSourceProducts(ServerCredentials activeRemoteMachine, RemoteMachineMetadata previousFailedSourceProducts) throws IOException, GraphException {
        Set<File> failedSourceProducts = this.invalidRemoteMachine.get(activeRemoteMachine);
        if (failedSourceProducts == null) {
            failedSourceProducts = new HashSet<File>();
            this.invalidRemoteMachine.put(activeRemoteMachine, failedSourceProducts);
        }
        File[] graphSourceProductFiles = previousFailedSourceProducts.getGraphSourceProductFiles();
        for (int i = 0; i < graphSourceProductFiles.length; i++) {
            this.processedSourceProductFiles.remove(graphSourceProductFiles[i]);
            failedSourceProducts.add(graphSourceProductFiles[i]);
        }
        deleteGraphFolder(previousFailedSourceProducts.getOutputProductRelativeFilePath());
    }

    public synchronized RemoteMachineMetadata computeNextGraphToRun(ServerCredentials activeRemoteMachine, char remoteMachineFileSeparator)
                                                                    throws IOException, GraphException {

        if (this.processedSourceProductFiles.size() < this.sourceProductFiles.length) {
            File[] graphSourceProductFiles = findNextUnprocessedSourceProductFiles(activeRemoteMachine, this.readOperatorNodes.size());
            if (graphSourceProductFiles != null) {
                String remoteOutputProductFolderName = "";
                String remoteMachineSharedFolderPath = activeRemoteMachine.getSharedFolderPath();
                for (int i = 0; i < this.readOperatorNodes.size(); i++) {
                    if (graphSourceProductFiles[i] == null) {
                        throw new IllegalStateException("Incomplete unprocessed source product files.");
                    }
                    Node readOperatorNode = this.readOperatorNodes.get(i);
                    String sourceProductFilePath = remoteMachineSharedFolderPath + remoteMachineFileSeparator + graphSourceProductFiles[i].getName();

                    int productFileIndex = -1;
                    for (int k = 0; k < this.sourceProductFiles.length; k++) {
                        if (this.sourceProductFiles[k] == graphSourceProductFiles[i]) {
                            productFileIndex = k;
                            break;
                        }
                    }
                    if (productFileIndex >= 0) {
                        if (remoteOutputProductFolderName.length() > 0) {
                            remoteOutputProductFolderName += "-";
                        }
                        remoteOutputProductFolderName += Integer.toString(productFileIndex + 1);
                        DomElement fileParam = readOperatorNode.getConfiguration().getChild("file");
                        fileParam.setValue(sourceProductFilePath);
                    } else {
                        throw new IllegalStateException("The graph source product file does not exist among the source product files.");
                    }
                }

                String outputProductRelativeFilePath = remoteOutputProductFolderName + remoteMachineFileSeparator + "remote-product.dim";

                String outputProductFilePathOnRemoteMachine = remoteMachineSharedFolderPath + remoteMachineFileSeparator + outputProductRelativeFilePath;
                DomElement fileParam = this.writeOperatorNode.getConfiguration().getChild("file");
                fileParam.setValue(outputProductFilePathOnRemoteMachine);

                Path graphFolderPathOnSharedMachine = deleteGraphFolder(outputProductRelativeFilePath);

                Files.createDirectory(graphFolderPathOnSharedMachine);

                File remoteGraphFileOnSharedMachine = graphFolderPathOnSharedMachine.resolve(this.graphFileForRemoteMachines.getName()).toFile();
                writeGraph(this.graph, remoteGraphFileOnSharedMachine);

                String remoteGraphRelativeFilePath = remoteOutputProductFolderName + remoteMachineFileSeparator + remoteGraphFileOnSharedMachine.getName();

                return new RemoteMachineMetadata(remoteGraphRelativeFilePath, outputProductRelativeFilePath, graphSourceProductFiles);
            }
        }
        return null;
    }

    public void addOutputProductsRelativeFilePath(String outputProductRelativeFilePath) {
        synchronized (this.outputProductsRelativeFilePath) {
            this.outputProductsRelativeFilePath.add(outputProductRelativeFilePath);
        }
    }

    public String[] getOutputProductsRelativeFilePath() {
        synchronized (this.outputProductsRelativeFilePath) {
            String[] array = new String[this.outputProductsRelativeFilePath.size()];
            this.outputProductsRelativeFilePath.toArray(array);
            return array;
        }
    }

    public Path computeAccessibleSharedFolderPath() {
        String sharedFolderPathAsString;
        if (StringUtils.isNullOrEmpty(this.localSharedFolderPath)) {
            sharedFolderPathAsString = this.masterSharedFolderURL;
        } else {
            sharedFolderPathAsString = this.localSharedFolderPath;
        }
        sharedFolderPathAsString = CloudExploitationPlatformOp.normalizePath(sharedFolderPathAsString);
        return Paths.get(sharedFolderPathAsString);
    }

    private Path deleteGraphFolder(String outputProductRelativeFilePath) throws IOException {
        Path accessibleSharedFolderPath = computeAccessibleSharedFolderPath();
        String relativePath = CloudExploitationPlatformOp.normalizePath(outputProductRelativeFilePath);
        Path outputProductFilePath = accessibleSharedFolderPath.resolve(relativePath);
        Path graphFolderPathOnSharedMachine = outputProductFilePath.getParent();
        if (Files.exists(graphFolderPathOnSharedMachine)) {
            if (!FileUtils.deleteFileTree(graphFolderPathOnSharedMachine)) {
                throw new IllegalStateException("Failed to delete the graph folder path '" + graphFolderPathOnSharedMachine.toString()+ "'.");
            }
        }
        return graphFolderPathOnSharedMachine;
    }

    private File[] findNextUnprocessedSourceProductFiles(ServerCredentials activeRemoteMachine, int count) {
        Set<File> failedSourceProducts = this.invalidRemoteMachine.get(activeRemoteMachine);
        File[] graphSourceProductFiles = new File[count];
        for (int i=0; i<graphSourceProductFiles.length; i++) {
            File sourceProductToProcess = null;
            for (int k = 0; k < this.sourceProductFiles.length && sourceProductToProcess == null; k++) {
                File currentSourceProduct = this.sourceProductFiles[this.sourceProductFilesIndex];
                this.sourceProductFilesIndex++;
                this.sourceProductFilesIndex = this.sourceProductFilesIndex % this.sourceProductFiles.length;
                if (failedSourceProducts == null || !failedSourceProducts.contains(currentSourceProduct)) {
                    if (this.processedSourceProductFiles.add(currentSourceProduct)) {
                        sourceProductToProcess = currentSourceProduct;
                    }
                }
            }
            if (sourceProductToProcess == null) {
                return null; // no available source product for the active remote machine
            } else {
                graphSourceProductFiles[i] = sourceProductToProcess;
            }
        }
        return graphSourceProductFiles;
    }

    static Graph readGraph(File inputXMLGraphFile) throws IOException, GraphException {
        FileReader fileReader = new FileReader(inputXMLGraphFile);
        try {
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            try {
                return GraphIO.read(fileReader);
            } finally {
                bufferedReader.close();
            }
        } finally {
            fileReader.close();
        }
    }

    static void writeGraph(Graph graph, File outputXMLGraphFile) throws IOException, GraphException {
        FileOutputStream fileOutputStream = new FileOutputStream(outputXMLGraphFile);
        try {
            OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream);
            try {
                BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);
                try {
                    GraphIO.write(graph, bufferedWriter);
                } finally {
                    bufferedWriter.close();
                }
            } finally {
                outputStreamWriter.close();
            }
        } finally {
            fileOutputStream.close();
        }
    }

    static void configureGraphReadNode(Node node) {
        DomElement config = node.getConfiguration();
        if (config == null) {
            config = new XppDomElement("parameters");
            node.setConfiguration(config);
        }
        DomElement fileParam = config.getChild("file");
        if (fileParam == null) {
            fileParam = new XppDomElement("file");
            config.addChild(fileParam);
        }
    }

    static void configureGraphWriteNode(Node node) {
        DomElement config = node.getConfiguration();
        if (config == null) {
            config = new XppDomElement("parameters");
            node.setConfiguration(config);
        }
        DomElement fileParam = config.getChild("file");
        if (fileParam == null) {
            fileParam = new XppDomElement("file");
            config.addChild(fileParam);
        }
        DomElement formatNameParam = config.getChild("formatName");
        if (formatNameParam == null) {
            formatNameParam = new XppDomElement("formatName");
            config.addChild(formatNameParam);
        }
        formatNameParam.setValue("BEAM-DIMAP");
    }
}
