package org.esa.snap.cloud.exploitation.platform;

import com.bc.ceres.binding.dom.DomElement;
import com.bc.ceres.binding.dom.XppDomElement;
import org.esa.snap.core.gpf.OperatorSpi;
import org.esa.snap.core.gpf.common.ReadOp;
import org.esa.snap.core.gpf.common.WriteOp;
import org.esa.snap.core.gpf.graph.Graph;
import org.esa.snap.core.gpf.graph.GraphException;
import org.esa.snap.core.gpf.graph.GraphIO;
import org.esa.snap.core.gpf.graph.Node;
import org.esa.snap.engine_utilities.util.FileIOUtils;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Created by jcoravu on 10/1/2019.
 */
public class RemoteMachinesGraphHelper {
    private final List<Node> readOperatorNodes;
    private final Node writeOperatorNode;
    private final Graph graph;
    private final File graphFileForRemoteMachines;
    private final Set<String> processedSourceProductFiles;
    private final List<String> outputProductsRelativeFilePath;
    private final Map<ServerCredentials, Set<String>> invalidRemoteMachine;
    private final boolean continueOnFailure;
    private final AtomicBoolean exceptionOccurred;
    private final SourceProducts sourceProducts;

    private int sourceProductFilesIndex;

    public RemoteMachinesGraphHelper(SourceProducts sourceProducts, String graphFilePathForRemoteMachines, boolean continueOnFailure)
                                     throws IOException, GraphException {

        this.sourceProducts = sourceProducts;
        this.continueOnFailure = continueOnFailure;

        this.graphFileForRemoteMachines = new File(graphFilePathForRemoteMachines);
        this.exceptionOccurred = new AtomicBoolean(false);

        this.outputProductsRelativeFilePath = new ArrayList<String>();
        this.sourceProductFilesIndex = 0;

        this.processedSourceProductFiles = new HashSet<String>();
        this.invalidRemoteMachine = new HashMap<ServerCredentials, Set<String>>();

        this.graph = readGraph(this.graphFileForRemoteMachines);

        this.readOperatorNodes = new ArrayList<Node>();
        List<Node> writeOperatorNodes = new ArrayList<Node>();
        for (int i = 0; i < this.graph.getNodeCount(); i++) {
            Node node = this.graph.getNode(i);
            if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(WriteOp.class))) {
                configureGraphWriteNode(node);
                writeOperatorNodes.add(node);
            } else if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(ReadOp.class))) {
                configureGraphReadNode(node);
                this.readOperatorNodes.add(node);
            }
        }
        if (writeOperatorNodes.size() == 0) {
            throw new IllegalStateException("The slave graph must contain the write operator.");
        }
        if (writeOperatorNodes.size() > 1) {
            throw new IllegalStateException("The slave graph must contain only one write operator. The actual number is " + writeOperatorNodes.size() + ".");
        }
        if (this.readOperatorNodes.size() == 0) {
            throw new IllegalStateException("The slave graph must contain at least one read operator. The read operator count must be equal with the source product count.");
        }
        if (this.sourceProducts.getSourceProductFileCount() % this.readOperatorNodes.size() != 0) {
            throw new IllegalStateException("The source product file count "+this.sourceProducts.getSourceProductFileCount()+" must be multiple of the graph read operator count "+this.readOperatorNodes.size()+".");
        }

        this.writeOperatorNode = writeOperatorNodes.get(0);
    }

    public String getMasterSharedFolderURL() {
        return this.sourceProducts.getNormalizedMasterSharedFolderURL();
    }

    public void setExceptionOccurredOnRemoteMachine(Exception exception) {
        synchronized (this.exceptionOccurred) {
            this.exceptionOccurred.set(true);
        }
    }

    private boolean isExceptionOccurredOnRemoteMachine() {
        synchronized (this.exceptionOccurred) {
            return this.exceptionOccurred.get();
        }
    }

    public boolean canContinueIfExceptionOccurredOnRemoteMachines() {
        if (isExceptionOccurredOnRemoteMachine()) {
            return this.continueOnFailure;
        }
        return true;
    }

    public synchronized void revalidateUnprocessedGraphSourceProducts(ServerCredentials activeRemoteMachine, RemoteMachineMetadata previousFailedSourceProducts)
                                                                      throws IOException, GraphException {

        Set<String> failedSourceProducts = this.invalidRemoteMachine.get(activeRemoteMachine);
        if (failedSourceProducts == null) {
            failedSourceProducts = new HashSet<String>();
            this.invalidRemoteMachine.put(activeRemoteMachine, failedSourceProducts);
        }
        String[] graphRelativeSourceProductFilePaths = previousFailedSourceProducts.getGraphRelativeSourceProductFilePaths();
        for (int i = 0; i < graphRelativeSourceProductFilePaths.length; i++) {
            this.processedSourceProductFiles.remove(graphRelativeSourceProductFilePaths[i]);
            failedSourceProducts.add(graphRelativeSourceProductFilePaths[i]);
        }
        deleteGraphFolder(previousFailedSourceProducts.getOutputProductRelativeFilePath());
    }

    public synchronized RemoteMachineMetadata computeNextGraphToRun(ServerCredentials activeRemoteMachine, IRemoteMachineFileSystem remoteMachineFileSystem)
                                                                    throws IOException, GraphException {

        if (this.processedSourceProductFiles.size() < this.sourceProducts.getSourceProductFileCount()) {
            String[] unprocessedRelativeSourceProductFilePaths = findNextUnprocessedSourceProductFiles(activeRemoteMachine, this.readOperatorNodes.size());
            if (unprocessedRelativeSourceProductFilePaths != null) {
                String remoteOutputProductFolderName = "";
                for (int i = 0; i < this.readOperatorNodes.size(); i++) {
                    if (unprocessedRelativeSourceProductFilePaths[i] == null) {
                        throw new IllegalStateException("Incomplete unprocessed source product files.");
                    }

                    int productFileIndex = -1;
                    for (int k = 0; k < this.sourceProducts.getSourceProductFileCount(); k++) {
                        if (this.sourceProducts.getRelativeSourceProductFilePathAt(k).equals(unprocessedRelativeSourceProductFilePaths[i])) {
                            productFileIndex = k;
                            break;
                        }
                    }
                    if (productFileIndex >= 0) {
                        if (remoteOutputProductFolderName.length() > 0) {
                            remoteOutputProductFolderName += "-";
                        }
                        remoteOutputProductFolderName += Integer.toString(productFileIndex + 1);

                        String relativeFilePath = remoteMachineFileSystem.normalizePath(unprocessedRelativeSourceProductFilePaths[i]);
                        if (relativeFilePath.charAt(0) != remoteMachineFileSystem.getFileSeparatorChar()) {
                            relativeFilePath = remoteMachineFileSystem.getFileSeparatorChar() + relativeFilePath;
                        }
                        String sourceProductFilePath = remoteMachineFileSystem.normalizePath(activeRemoteMachine.getSharedFolderPath() + relativeFilePath);

                        Node readOperatorNode = this.readOperatorNodes.get(i);
                        DomElement fileParam = readOperatorNode.getConfiguration().getChild("file");
                        fileParam.setValue(sourceProductFilePath);
                    } else {
                        throw new IllegalStateException("The graph source product file does not exist among the source product files.");
                    }
                }

                String outputProductRelativeFilePath = remoteMachineFileSystem.normalizePath(remoteOutputProductFolderName + "/" + "remote-product.dim");

                String outputProductFilePathOnRemoteMachine = remoteMachineFileSystem.normalizePath(activeRemoteMachine.getSharedFolderPath() + "/" + outputProductRelativeFilePath);

                DomElement fileParam = this.writeOperatorNode.getConfiguration().getChild("file");
                fileParam.setValue(outputProductFilePathOnRemoteMachine);

                Path graphFolderPathOnSharedMachine = deleteGraphFolder(outputProductRelativeFilePath);

                Files.createDirectory(graphFolderPathOnSharedMachine);

                File remoteGraphFileOnSharedMachine = graphFolderPathOnSharedMachine.resolve(this.graphFileForRemoteMachines.getName()).toFile();
                writeGraph(this.graph, remoteGraphFileOnSharedMachine);

                String remoteGraphRelativeFilePath = remoteMachineFileSystem.normalizePath(remoteOutputProductFolderName + "/" + remoteGraphFileOnSharedMachine.getName());

                return new RemoteMachineMetadata(remoteGraphRelativeFilePath, outputProductRelativeFilePath, unprocessedRelativeSourceProductFilePaths);
            }
        }
        return null;
    }

    public void addOutputProductsRelativeFilePath(String outputProductRelativeFilePath) {
        synchronized (this.outputProductsRelativeFilePath) {
            this.outputProductsRelativeFilePath.add(outputProductRelativeFilePath);
        }
    }

    public String[] getOutputProductsRelativeFilePath() {
        synchronized (this.outputProductsRelativeFilePath) {
            String[] array = new String[this.outputProductsRelativeFilePath.size()];
            this.outputProductsRelativeFilePath.toArray(array);
            return array;
        }
    }

    public Path getLocalSharedFolderPath() {
        return Paths.get(this.sourceProducts.getNormalizedLocalSharedFolderPath());
    }

    private Path deleteGraphFolder(String outputProductRelativeFilePath) throws IOException {
        Path accessibleSharedFolderPath = getLocalSharedFolderPath();
        String relativePath = CloudExploitationPlatformOp.normalizePath(outputProductRelativeFilePath);
        Path outputProductFilePath = accessibleSharedFolderPath.resolve(relativePath);
        Path graphFolderPathOnSharedMachine = outputProductFilePath.getParent();
        if (Files.exists(graphFolderPathOnSharedMachine)) {
            // delete the folder
            FileIOUtils.deleteFolder(graphFolderPathOnSharedMachine);
            // check if the folder still exists
            if (Files.exists(graphFolderPathOnSharedMachine)) {
                throw new IllegalStateException("Failed to delete the graph folder path '" + graphFolderPathOnSharedMachine.toString()+ "'.");
            }
        }
        return graphFolderPathOnSharedMachine;
    }

    private String[] findNextUnprocessedSourceProductFiles(ServerCredentials activeRemoteMachine, int count) {
        Set<String> failedRelativeSourceProductFilePaths = this.invalidRemoteMachine.get(activeRemoteMachine);
        String[] graphRelativeSourceProductFilePaths = new String[count];
        for (int i=0; i<graphRelativeSourceProductFilePaths.length; i++) {
            String relativeSourceProductFilePathToProcess = null;
            for (int k = 0; k < this.sourceProducts.getSourceProductFileCount() && relativeSourceProductFilePathToProcess == null; k++) {
                String currentRelativeSourceProductFilePath = this.sourceProducts.getRelativeSourceProductFilePathAt(this.sourceProductFilesIndex);
                this.sourceProductFilesIndex++;
                this.sourceProductFilesIndex = this.sourceProductFilesIndex % this.sourceProducts.getSourceProductFileCount();
                if (failedRelativeSourceProductFilePaths == null || !failedRelativeSourceProductFilePaths.contains(currentRelativeSourceProductFilePath)) {
                    if (this.processedSourceProductFiles.add(currentRelativeSourceProductFilePath)) {
                        relativeSourceProductFilePathToProcess = currentRelativeSourceProductFilePath;
                    }
                }
            }
            if (relativeSourceProductFilePathToProcess == null) {
                return null; // no available source product for the active remote machine
            } else {
                graphRelativeSourceProductFilePaths[i] = relativeSourceProductFilePathToProcess;
            }
        }
        return graphRelativeSourceProductFilePaths;
    }

    static Graph readGraph(File inputXMLGraphFile) throws IOException, GraphException {
        FileReader fileReader = new FileReader(inputXMLGraphFile);
        try {
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            try {
                return GraphIO.read(fileReader);
            } finally {
                bufferedReader.close();
            }
        } finally {
            fileReader.close();
        }
    }

    static void writeGraph(Graph graph, File outputXMLGraphFile) throws IOException, GraphException {
        FileOutputStream fileOutputStream = new FileOutputStream(outputXMLGraphFile);
        try {
            OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream);
            try {
                BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);
                try {
                    GraphIO.write(graph, bufferedWriter);
                } finally {
                    bufferedWriter.close();
                }
            } finally {
                outputStreamWriter.close();
            }
        } finally {
            fileOutputStream.close();
        }
    }

    static void configureGraphReadNode(Node node) {
        DomElement config = node.getConfiguration();
        if (config == null) {
            config = new XppDomElement("parameters");
            node.setConfiguration(config);
        }
        DomElement fileParam = config.getChild("file");
        if (fileParam == null) {
            fileParam = new XppDomElement("file");
            config.addChild(fileParam);
        }
    }

    static void configureGraphWriteNode(Node node) {
        DomElement config = node.getConfiguration();
        if (config == null) {
            config = new XppDomElement("parameters");
            node.setConfiguration(config);
        }
        DomElement fileParam = config.getChild("file");
        if (fileParam == null) {
            fileParam = new XppDomElement("file");
            config.addChild(fileParam);
        }
        DomElement formatNameParam = config.getChild("formatName");
        if (formatNameParam == null) {
            formatNameParam = new XppDomElement("formatName");
            config.addChild(formatNameParam);
        }
        formatNameParam.setValue("BEAM-DIMAP");
    }
}
