package org.esa.snap.cloud.exploitation.platform;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.esa.snap.core.gpf.graph.GraphException;

import java.io.IOException;
import java.util.logging.Level;

/**
 * Created by jcoravu on 16/1/2019.
 */
public class LinuxRemoteMachineExecutor extends AbstractRemoteMachineExecutor {

    public LinuxRemoteMachineExecutor(String sharedFolderURL, String sharedFolderUsername, String sharedFolderPassword, ServerCredentials serverCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {
        super(sharedFolderURL, sharedFolderUsername, sharedFolderPassword, serverCredentials, remoteMachinesGraphHelper);
    }

    private String buildRunGPTCommand(char fileSeparator, String remoteMachineSharedFolder, String graphRelativeFilePath) {
        StringBuilder command = new StringBuilder();
        command.append("sh ")
                .append("gpt")
                .append(" ")
                .append(normalizePath(remoteMachineSharedFolder))
                .append(fileSeparator)
                .append(normalizePath(graphRelativeFilePath));
        return command.toString();
    }

    @Override
    protected OutputConsoleBuffer runGraph(Session session, char fileSeparator, String remoteMachineSharedFolder, String graphRelativeFilePath) throws IOException, JSchException {
        String command = buildRunGPTCommand(fileSeparator, remoteMachineSharedFolder, graphRelativeFilePath);
        OutputConsoleBuffer consoleBuffer = new OutputConsoleBuffer();
        int exitStatus = SSHConnection.executeLinuxCommand(session, command.toString(), null, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        return consoleBuffer;
    }

    @Override
    protected void execute(Session session) throws IOException, GraphException, SftpException, JSchException {
        String superUserPassword = this.remoteMachineCredentials.getPassword();
        String remoteMachineSharedFolderPath = normalizePath(this.remoteMachineCredentials.getSharedFolderPath());

        // make the shared folder on the remote machine
        String command = buildMakeSharedFolderCommand(remoteMachineSharedFolderPath);
        OutputConsoleBuffer consoleBuffer = new OutputConsoleBuffer();
        int exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        boolean sharedFolderCreated = checkMakeSharedFolderMessage(consoleBuffer, remoteMachineSharedFolderPath);

        // change mode of the shared folder on the remote machine
        command = buildChangeModeSharedFolderCommand(remoteMachineSharedFolderPath);
        consoleBuffer = new OutputConsoleBuffer();
        exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        if (checkChangeModeSharedFolderMessage(consoleBuffer)) {
            command = buildMountSharedFolderCommand(remoteMachineSharedFolderPath, this.masterSharedFolderPassword);
            consoleBuffer = new OutputConsoleBuffer();
            exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

            command = buildMountSharedFolderCommand(remoteMachineSharedFolderPath, "..."); // do not write the password in the log file
            logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

            if (checkMountSharedFolderMessage(consoleBuffer, remoteMachineSharedFolderPath)) {
                runGraphs(session, '/');

                command = buildUnmountSharedFolderCommand(remoteMachineSharedFolderPath);
                consoleBuffer = new OutputConsoleBuffer();
                exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

                logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));
            }

            if (sharedFolderCreated) {
                command = buildRemoveSharedFolderCommand(remoteMachineSharedFolderPath);
                consoleBuffer = new OutputConsoleBuffer();
                exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

                logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));
            }
        }
    }

    private String buildUnmountSharedFolderCommand(String remoteMachineSharedFolderPath) {
        return "umount " + remoteMachineSharedFolderPath;
    }

    private String buildRemoveSharedFolderCommand(String remoteMachineSharedFolderPath) {
        return "rmdir " + remoteMachineSharedFolderPath;
    }

    private String buildMakeSharedFolderCommand(String remoteMachineSharedFolderPath) {
        return "mkdir " + remoteMachineSharedFolderPath;
    }

    private String buildChangeModeSharedFolderCommand(String remoteMachineSharedFolderPath) {
        return "chmod -R 0777 "+ remoteMachineSharedFolderPath;
    }

    private String buildMountSharedFolderCommand(String remoteMachineSharedFolderPath, String masterSharedFolderPassword) {
        StringBuilder command = new StringBuilder();
        command.append("mount.cifs")
                .append(" ")
                .append(normalizePath(this.masterSharedFolderURL))
                .append(" ")
                .append(remoteMachineSharedFolderPath)
                .append(" ")
                .append("-o user=")
                .append(this.masterSharedFolderUsername)
                .append(",password=")
                .append(masterSharedFolderPassword)
                .append(",file_mode=0777,dir_mode=0777,noperm");
        return command.toString();
    }

    private boolean checkMakeSharedFolderMessage(OutputConsoleBuffer consoleBuffer, String sharedFolderPath) {
        String valuesToCheck[] = new String[] { "cannot ", "file exists" };
        if (consoleBuffer.containsIgnoreCaseOnNormalStream(valuesToCheck)) {
            logger.log(Level.FINE, buildLogMessage("The folder '"+sharedFolderPath+"' already exists on the remote machine."));
            return false;
        }
        return true;
    }

    private boolean checkMountSharedFolderMessage(OutputConsoleBuffer consoleBuffer, String sharedFolderPath) {
        String valuesToCheck[] = new String[] { "Permission denied", "command not found", "bad UNC" };
        if (consoleBuffer.containsIgnoreCase(valuesToCheck)) {
            logger.log(Level.FINE, buildLogMessage("The folder '"+sharedFolderPath+"' could not be mounted on the remote machine."));
            return false; // mount.cifs: command not found | mount.cifs: bad UNC (\PCD3331shared) | mount error(13): Permission denied
        }
        return true;
    }

    private static boolean checkChangeModeSharedFolderMessage(OutputConsoleBuffer consoleBuffer) {
        String valuesToCheck[] = new String[] { "cannot " };
        if (consoleBuffer.containsIgnoreCaseOnNormalStream(valuesToCheck)) {
            return false;
        }
        return true;
    }

    private static String normalizePath(String path) {
        return path.replace('\\', '/');
    }
}
