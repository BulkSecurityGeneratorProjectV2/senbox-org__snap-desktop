package org.esa.snap.cloud.exploitation.platform;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.esa.snap.cloud.exploitation.platform.executors.OutputConsoleBuffer;
import org.esa.snap.cloud.exploitation.platform.executors.SSHConnection;
import org.esa.snap.core.gpf.graph.GraphException;

import java.io.IOException;
import java.util.logging.Level;

/**
 * Created by jcoravu on 16/1/2019.
 */
public class LinuxRemoteMachineExecutor extends AbstractRemoteMachineExecutor {

    public LinuxRemoteMachineExecutor(String sharedFolderUsername, String sharedFolderPassword,
                                      ServerCredentials serverCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {

        super(sharedFolderUsername, sharedFolderPassword, serverCredentials, remoteMachinesGraphHelper);
    }

    @Override
    protected OutputConsoleBuffer runGraph(Session session, char fileSeparator, String remoteMachineSharedFolder, String graphRelativeFilePath)
                                           throws IOException, JSchException {

        String command = buildRunGPTCommand(fileSeparator, remoteMachineSharedFolder, graphRelativeFilePath);
        OutputConsoleBuffer consoleBuffer = new OutputConsoleBuffer();
        int exitStatus = SSHConnection.executeLinuxCommand(session, command.toString(), null, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        return consoleBuffer;
    }

    @Override
    protected void execute(Session session) throws IOException, GraphException, SftpException, JSchException {
        String superUserPassword = this.remoteMachineCredentials.getPassword();
        String remoteMachineSharedFolderPath = CloudExploitationPlatformOp.normalizeLinuxPath(this.remoteMachineCredentials.getSharedFolderPath());

        // make the shared folder on the remote machine
        String command = CloudExploitationPlatformOp.buildMakeFolderCommand(remoteMachineSharedFolderPath);
        OutputConsoleBuffer consoleBuffer = new OutputConsoleBuffer();
        int exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        boolean sharedFolderCreated = checkMakeSharedFolderMessage(consoleBuffer, remoteMachineSharedFolderPath);

        // change mode of the shared folder on the remote machine
        command = CloudExploitationPlatformOp.buildChangeFolderModeCommand(remoteMachineSharedFolderPath);
        consoleBuffer = new OutputConsoleBuffer();
        exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        if (checkChangeModeSharedFolderMessage(consoleBuffer)) {
            String masterSharedFolderURL = CloudExploitationPlatformOp.normalizeLinuxPath(this.remoteMachinesGraphHelper.getMasterSharedFolderURL());

            command = CloudExploitationPlatformOp.buildMountSharedFolderCommand(masterSharedFolderURL, remoteMachineSharedFolderPath,
                                                                                this.masterSharedFolderUsername, this.masterSharedFolderPassword);

            consoleBuffer = new OutputConsoleBuffer();
            exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

            command = CloudExploitationPlatformOp.buildMountSharedFolderCommand(masterSharedFolderURL, remoteMachineSharedFolderPath,
                                            this.masterSharedFolderUsername, "..."); // do not write the password in the log file
            logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

            if (checkMountSharedFolderMessage(consoleBuffer, remoteMachineSharedFolderPath)) {
                runGraphs(session, '/');

                command = CloudExploitationPlatformOp.buildUnmountSharedFolderCommand(remoteMachineSharedFolderPath);
                consoleBuffer = new OutputConsoleBuffer();
                exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

                logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));
            }

            if (sharedFolderCreated) {
                command = CloudExploitationPlatformOp.buildRemoveFolderCommand(remoteMachineSharedFolderPath);
                consoleBuffer = new OutputConsoleBuffer();
                exitStatus = SSHConnection.executeLinuxCommand(session, command, superUserPassword, consoleBuffer);

                logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));
            }
        }
    }

    private String buildRunGPTCommand(char fileSeparator, String remoteMachineSharedFolder, String graphRelativeFilePath) {
        StringBuilder command = new StringBuilder();
        command.append("sh ")
                .append("gpt")
                .append(" ")
                .append(CloudExploitationPlatformOp.normalizeLinuxPath(remoteMachineSharedFolder))
                .append(fileSeparator)
                .append(CloudExploitationPlatformOp.normalizeLinuxPath(graphRelativeFilePath));
        return command.toString();
    }

    private boolean checkMakeSharedFolderMessage(OutputConsoleBuffer consoleBuffer, String sharedFolderPath) {
        String valuesToCheck[] = new String[] { "cannot ", "file exists" };
        if (consoleBuffer.containsIgnoreCaseOnNormalStream(valuesToCheck)) {
            logger.log(Level.FINE, buildLogMessage("The folder '"+sharedFolderPath+"' already exists on the remote machine."));
            return false;
        }
        return true;
    }

    private boolean checkMountSharedFolderMessage(OutputConsoleBuffer consoleBuffer, String sharedFolderPath) {
        String valuesToCheck[] = new String[] { "Permission denied", "command not found", "bad UNC" };
        if (consoleBuffer.containsIgnoreCase(valuesToCheck)) {
            logger.log(Level.FINE, buildLogMessage("The folder '"+sharedFolderPath+"' could not be mounted on the remote machine."));
            return false; // mount.cifs: command not found | mount.cifs: bad UNC (\PCD3331shared) | mount error(13): Permission denied
        }
        return true;
    }

    private static boolean checkChangeModeSharedFolderMessage(OutputConsoleBuffer consoleBuffer) {
        String valuesToCheck[] = new String[] { "cannot " };
        if (consoleBuffer.containsIgnoreCaseOnNormalStream(valuesToCheck)) {
            return false;
        }
        return true;
    }
}
