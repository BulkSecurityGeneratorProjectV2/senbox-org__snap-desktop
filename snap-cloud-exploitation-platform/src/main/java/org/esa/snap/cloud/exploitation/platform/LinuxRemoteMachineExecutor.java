package org.esa.snap.cloud.exploitation.platform;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.SftpException;
import org.esa.snap.cloud.exploitation.platform.executors.OutputConsoleBuffer;
import org.esa.snap.core.gpf.graph.GraphException;

import java.io.IOException;
import java.util.logging.Level;

/**
 * Created by jcoravu on 16/1/2019.
 */
public class LinuxRemoteMachineExecutor extends AbstractRemoteMachineExecutor {

    public LinuxRemoteMachineExecutor(String masterSharedFolderURL, String sharedFolderUsername, String sharedFolderPassword,
                                      RemoteMachineCredentials serverCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {

        super(masterSharedFolderURL, sharedFolderUsername, sharedFolderPassword, serverCredentials, remoteMachinesGraphHelper);
    }

    @Override
    public String normalizePath(String path) {
        return path.replace('\\', '/');
    }

    @Override
    public char getFileSeparatorChar() {
        return '/';
    }

    @Override
    protected int runGraph(String graphFilePathToProcess) throws IOException, JSchException {
        String command = buildRunGPTCommand(graphFilePathToProcess);
        OutputConsoleBuffer consoleBuffer = new OutputConsoleBuffer();
        int exitStatus = this.sshConnection.executeLinuxCommand(command.toString(), null, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        return exitStatus;
    }

    @Override
    protected void runCommands() throws IOException, GraphException, SftpException, JSchException {
        String superUserPassword = this.remoteMachineCredentials.getPassword();
        String remoteMachineSharedFolderPath = normalizePath(this.remoteMachineCredentials.getSharedFolderPath());

        // make the shared folder on the remote machine
        String command = CloudExploitationPlatformOp.buildLinuxMakeFolderCommand(remoteMachineSharedFolderPath);
        OutputConsoleBuffer consoleBuffer = new OutputConsoleBuffer();
        int exitStatus = this.sshConnection.executeLinuxCommand(command, superUserPassword, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        boolean sharedFolderCreated;
        if (exitStatus == 0) {
            sharedFolderCreated = true;
        } else {
            sharedFolderCreated = checkMakeSharedFolderMessage(consoleBuffer, remoteMachineSharedFolderPath);
        }

        // change mode of the shared folder on the remote machine
        command = CloudExploitationPlatformOp.buildLinuxChangeModeFolderCommand(remoteMachineSharedFolderPath);
        consoleBuffer = new OutputConsoleBuffer();
        exitStatus = this.sshConnection.executeLinuxCommand(command, superUserPassword, consoleBuffer);

        logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

        if (exitStatus == 0) {
            String normalizedMasterSharedFolderURL = normalizePath(this.masterSharedFolderURL);

            // mount the local shared folder
            command = CloudExploitationPlatformOp.buildLinuxMountSharedFolderCommand(normalizedMasterSharedFolderURL, remoteMachineSharedFolderPath,
                                                                                this.masterSharedFolderUsername, this.masterSharedFolderPassword);

            consoleBuffer = new OutputConsoleBuffer();
            exitStatus = this.sshConnection.executeLinuxCommand(command, superUserPassword, consoleBuffer);

            // do not write the password in the log file
            command = CloudExploitationPlatformOp.buildLinuxMountSharedFolderCommand(normalizedMasterSharedFolderURL, remoteMachineSharedFolderPath,
                                            this.masterSharedFolderUsername, "...");
            logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));

            if (exitStatus == 0) {
                // the remote machine shared folder has been mounted successfully
                runGraphs();

                // unmount the local shared folder
                command = CloudExploitationPlatformOp.buildUnmountUnixSharedFolderCommand(remoteMachineSharedFolderPath);
                consoleBuffer = new OutputConsoleBuffer();
                exitStatus = this.sshConnection.executeLinuxCommand(command, superUserPassword, consoleBuffer);

                logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));
            }

            if (sharedFolderCreated) {
                // remove the local shared folder
                command = CloudExploitationPlatformOp.buildUnixRemoveFolderCommand(remoteMachineSharedFolderPath);
                consoleBuffer = new OutputConsoleBuffer();
                exitStatus = this.sshConnection.executeLinuxCommand(command, superUserPassword, consoleBuffer);

                logger.log(Level.FINE, buildLogMessage(command, consoleBuffer, exitStatus));
            }
        }
    }

    private boolean checkMakeSharedFolderMessage(OutputConsoleBuffer consoleBuffer, String sharedFolderPath) {
        String valuesToCheck[] = new String[] { "cannot ", "file exists" };
        if (consoleBuffer.containsIgnoreCaseOnNormalStream(valuesToCheck)) {
            logger.log(Level.FINE, buildLogMessage("The folder '"+sharedFolderPath+"' already exists on the remote machine."));
            return false;
        }
        return true;
    }

    private static String buildRunGPTCommand(String graphFilePathToProcess) {
        StringBuilder command = new StringBuilder();
        command.append("sh")
                .append(" ")

                //TODO Jean remove
                //.append("/home/jean/snap-desktop-v5.0/bin/")
                //.append("/usr/local/snap/bin/")
                .append("/opt/snap/bin/")

                .append("gpt")
                .append(" ")
                .append(CloudExploitationPlatformOp.normalizeUnixPath(graphFilePathToProcess));
        return command.toString();
    }
}
