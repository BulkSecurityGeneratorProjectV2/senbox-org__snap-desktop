package org.esa.snap.cloud.exploitation.platform;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.esa.snap.core.gpf.graph.GraphException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by jcoravu on 22/1/2019.
 */
public abstract class AbstractRemoteMachineExecutor {

    protected static final Logger logger = Logger.getLogger(AbstractRemoteMachineExecutor.class.getName());

    protected final String masterSharedFolderURL;
    protected final String masterSharedFolderUsername;
    protected final String masterSharedFolderPassword;
    protected final ServerCredentials remoteMachineCredentials;

    private final RemoteMachinesGraphHelper remoteMachinesGraphHelper;

    protected AbstractRemoteMachineExecutor(String masterSharedFolderURL, String masterSharedFolderUsername, String masterSharedFolderPassword,
                                            ServerCredentials remoteMachineCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {

        this.masterSharedFolderURL = masterSharedFolderURL;
        this.masterSharedFolderUsername = masterSharedFolderUsername;
        this.masterSharedFolderPassword = masterSharedFolderPassword;
        this.remoteMachineCredentials = remoteMachineCredentials;
        this.remoteMachinesGraphHelper = remoteMachinesGraphHelper;
    }

    protected abstract OutputConsoleBuffer runGraph(Session session, char fileSeparator, String remoteMachineSharedFolder, String graphRelativeFilePath) throws IOException, JSchException;

    protected abstract void execute(Session session) throws IOException, GraphException, SftpException, JSchException;

    public final void execute() throws JSchException, SftpException, IOException, GraphException {
        if (this.remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
            try {
                logger.log(Level.FINE, buildStartLogMessage());

                SSHConnection connection = new SSHConnection(this.remoteMachineCredentials.getHostName(), this.remoteMachineCredentials.getPortNumber(), this.remoteMachineCredentials.getUsername(), this.remoteMachineCredentials.getPassword());
                Session session = connection.openSesssion();
                try {
                    if (this.remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
                        execute(session);
                    }
                } finally {
                    session.disconnect();
                }
            } catch (JSchException exception) {
                if (exception.getCause() instanceof java.net.UnknownHostException || exception.getCause() instanceof java.net.ConnectException) {
                    logger.log(Level.SEVERE, buildFailedToConnectLogMessage(), exception.getMessage());
                } else {
                    throw exception;
                }
            }
        }
    }

    public void setExceptionOccurredOnRemoteMachine(Exception exception) {
        this.remoteMachinesGraphHelper.setExceptionOccurredOnRemoteMachine(exception);
    }

    protected final void runGraphs(Session session, char fileSeparator) throws IOException, GraphException, SftpException, JSchException {
        boolean canContinue = true;
        String remoteMachineSharedFolder = this.remoteMachineCredentials.getSharedFolderPath();
        while (canContinue && this.remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
            RemoteMachineMetadata remoteMachineMetadata = this.remoteMachinesGraphHelper.computeNextGraphToRun(this.remoteMachineCredentials, remoteMachineSharedFolder, fileSeparator);
            if (remoteMachineMetadata == null) {
                canContinue = false;
            } else {
                boolean outputProductCreated = false;
                try {
                    OutputConsoleBuffer consoleBuffer = runGraph(session, fileSeparator, remoteMachineSharedFolder, remoteMachineMetadata.getGraphRelativeFilePath());
                    String valuesToCheck[] = new String[] { "done" };
                    if (consoleBuffer.containsIgnoreCaseOnNormalStream(valuesToCheck)) {
                        // the graph has not been successfully executed
                        Path outputProductFilePath = Paths.get(this.masterSharedFolderURL).resolve(remoteMachineMetadata.getOutputProductRelativeFilePath());
                        if (Files.exists(outputProductFilePath)) {
                            outputProductCreated = true;
                        }
                    }
                } finally {
                    if (outputProductCreated) {
                        this.remoteMachinesGraphHelper.addOutputProductsRelativeFilePath(remoteMachineMetadata.getOutputProductRelativeFilePath());
                    } else {
                        this.remoteMachinesGraphHelper.revalidateUnprocessedGraphSourceProducts(this.remoteMachineCredentials, remoteMachineMetadata);
                    }
                }
            }
        }
    }

    protected final String buildLogMessage(String command, OutputConsoleBuffer consoleBuffer, int exitStatus) {
        String newLineAndTab = "\n\t";
        String normalKey = "Normal: ";
        String errorKey = "Error: ";

        String emptySpaces = buildStringWithEmptySpaces(normalKey.length());
        String normalMessages = consoleBuffer.getNormalStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        emptySpaces = buildStringWithEmptySpaces(errorKey.length());
        String errorMessages = consoleBuffer.getErrorStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("] Command: ")
                .append(command)
                .append(newLineAndTab)
                .append("Exit status: ")
                .append(exitStatus)
                .append(newLineAndTab)
                .append(normalKey)
                .append(normalMessages)
                .append(newLineAndTab)
                .append(errorKey)
                .append(errorMessages);
        return message.toString();
    }

    protected final String buildLogMessage(String message) {
        StringBuilder result = new StringBuilder();
        result.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("] ")
                .append(message);
        return result.toString();
    }

    private String buildStartLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Execute graphs on the remote machine.");
        return message.toString();
    }

    private String buildFailedToConnectLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Failed to connect to the remote machine.");
        return message.toString();
    }

    public String buildFailedLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Failed to execute the graph on the remote machine.");
        return message.toString();
    }

    private static String buildStringWithEmptySpaces(int length) {
        StringBuilder result = new StringBuilder(length);
        for (int i=0; i<length; i++) {
            result.append(' ');
        }
        return result.toString();
    }
}
