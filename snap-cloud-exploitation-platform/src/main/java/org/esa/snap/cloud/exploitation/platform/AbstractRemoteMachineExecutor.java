package org.esa.snap.cloud.exploitation.platform;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.apache.commons.lang.StringUtils;
import org.esa.snap.cloud.exploitation.platform.executors.OutputConsoleBuffer;
import org.esa.snap.cloud.exploitation.platform.executors.SSHConnection;
import org.esa.snap.core.gpf.graph.GraphException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by jcoravu on 22/1/2019.
 */
public abstract class AbstractRemoteMachineExecutor implements IRemoteMachineFileSystem {

    protected static final Logger logger = Logger.getLogger(AbstractRemoteMachineExecutor.class.getName());

    protected final String masterSharedFolderURL;
    protected final String masterSharedFolderUsername;
    protected final String masterSharedFolderPassword;
    protected final RemoteMachineCredentials remoteMachineCredentials;
    protected final RemoteMachinesGraphHelper remoteMachinesGraphHelper;
    protected final SSHConnection sshConnection;

    protected AbstractRemoteMachineExecutor(String masterSharedFolderURL, String masterSharedFolderUsername, String masterSharedFolderPassword,
                                            RemoteMachineCredentials remoteMachineCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {

        this.masterSharedFolderURL = masterSharedFolderURL;
        this.masterSharedFolderUsername = masterSharedFolderUsername;
        this.masterSharedFolderPassword = masterSharedFolderPassword;
        this.remoteMachineCredentials = remoteMachineCredentials;
        this.remoteMachinesGraphHelper = remoteMachinesGraphHelper;

        this.sshConnection = new SSHConnection(this.remoteMachineCredentials.getHostName(), this.remoteMachineCredentials.getPortNumber(), this.remoteMachineCredentials.getUsername(), this.remoteMachineCredentials.getPassword());
    }

    protected abstract int runGraph(String gptFilePath, String graphFilePathToProcess) throws IOException, JSchException;

    protected abstract void runCommands() throws IOException, GraphException, SftpException, JSchException;

    public final void stopRunningCommand() throws Exception {
        this.sshConnection.stopRunningCommand();
    }

    public final void execute() throws JSchException, SftpException, IOException, GraphException {
        if (canContinueRunning()) {
            logger.log(Level.FINE, buildStartLogMessage());

            try {
                this.sshConnection.connect();
                try {
                    if (canContinueRunning()) {
                        runCommands();
                    }
                } finally {
                    this.sshConnection.disconnect();
                }
            } catch (JSchException exception) {
                if (exception.getCause() instanceof java.net.UnknownHostException || exception.getCause() instanceof java.net.ConnectException) {
                    logger.log(Level.SEVERE, buildFailedToConnectLogMessage(), exception);
                    setExceptionOccurredOnRemoteMachine(exception);
                } else {
                    throw exception;
                }
            } finally {
                this.sshConnection.disconnect(); // invoke again the disconnect method
            }
        }
    }

    public final void setExceptionOccurredOnRemoteMachine(Exception exception) {
        this.remoteMachinesGraphHelper.setExceptionOccurredOnRemoteMachine(exception);
    }

    protected final boolean canContinueRunning() {
        return this.remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines() && !this.sshConnection.isStopped();
    }

    protected final void runGraphs() throws IOException, GraphException, SftpException, JSchException {
        boolean canRunGraphs = true;
        while (canRunGraphs && canContinueRunning()) {
            RemoteMachineMetadata remoteMachineMetadata = this.remoteMachinesGraphHelper.computeNextGraphToRun(this.remoteMachineCredentials, this);
            if (remoteMachineMetadata == null) {
                canRunGraphs = false;
            } else {
                boolean outputProductCreated = false;
                try {
                    String relativeFilePath = normalizePath(remoteMachineMetadata.getGraphRelativeFilePath());
                    if (relativeFilePath.charAt(0) != getFileSeparatorChar()) {
                        relativeFilePath = getFileSeparatorChar() + relativeFilePath;
                    }
                    String graphFilePathToProcess = "\"" + normalizePath(this.remoteMachineCredentials.getSharedFolderPath() + relativeFilePath) + "\"";

                    String gptFilePath = this.remoteMachineCredentials.getGPTFilePath();
                    if (StringUtils.isBlank(gptFilePath)) {
                        gptFilePath = "gpt";
                    } else {
                        gptFilePath = normalizePath(gptFilePath);
                        if (!gptFilePath.startsWith("\"") && !gptFilePath.endsWith("\"")) {
                            gptFilePath = "\"" + gptFilePath + "\"";
                        }
                    }

                    int exitStatus = runGraph(gptFilePath, graphFilePathToProcess);
                    if (exitStatus == 0) {
                        // the graph has not been successfully executed
                        Path localSharedFolderPath = this.remoteMachinesGraphHelper.getLocalOutputFolderPath().getParent();
                        String relativePath = CloudExploitationPlatformOp.normalizePath(remoteMachineMetadata.getOutputProductRelativeFilePath());
                        Path localOutputProductFilePath = localSharedFolderPath.resolve(relativePath);
                        if (Files.exists(localOutputProductFilePath)) {
                            outputProductCreated = true;
                        }
                    } else {
                        logger.log(Level.FINE, buildLogMessage("Failed to run the graph on the remote machine. Exist status " + exitStatus+"."));
                    }
                } finally {
                    if (outputProductCreated) {
                        this.remoteMachinesGraphHelper.addOutputProductsRelativeFilePath(remoteMachineMetadata.getOutputProductRelativeFilePath());
                    } else {
                        this.remoteMachinesGraphHelper.revalidateUnprocessedGraphSourceProducts(this.remoteMachineCredentials, remoteMachineMetadata);
                    }
                }
            }
        }
    }

    protected final String buildLogMessage(String command, OutputConsoleBuffer outputConsole, int exitStatus) {
        return CloudExploitationPlatformOp.buildLogMessage(this.remoteMachineCredentials.getHostName(), command, outputConsole, exitStatus);
    }

    protected final String buildLogMessage(String message) {
        StringBuilder result = new StringBuilder();
        result.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("] ")
                .append(message);
        return result.toString();
    }

    private String buildStartLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Execute graphs on the remote machine.");
        return message.toString();
    }

    private String buildFailedToConnectLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Failed to connect to the remote machine.");
        return message.toString();
    }

    public String buildFailedLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Failed to execute the graph on the remote machine.");
        return message.toString();
    }
}
