package org.esa.snap.cloud.exploitation.platform;

import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import org.esa.snap.cloud.exploitation.platform.executors.OutputConsoleBuffer;
import org.esa.snap.cloud.exploitation.platform.executors.SSHConnection;
import org.esa.snap.core.gpf.graph.GraphException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by jcoravu on 22/1/2019.
 */
public abstract class AbstractRemoteMachineExecutor implements IRemoteMachineFileSystem {

    protected static final Logger logger = Logger.getLogger(AbstractRemoteMachineExecutor.class.getName());

    protected final String masterSharedFolderUsername;
    protected final String masterSharedFolderPassword;
    protected final ServerCredentials remoteMachineCredentials;
    protected final RemoteMachinesGraphHelper remoteMachinesGraphHelper;

    protected AbstractRemoteMachineExecutor(String masterSharedFolderUsername, String masterSharedFolderPassword,
                                            ServerCredentials remoteMachineCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {

        this.masterSharedFolderUsername = masterSharedFolderUsername;
        this.masterSharedFolderPassword = masterSharedFolderPassword;
        this.remoteMachineCredentials = remoteMachineCredentials;
        this.remoteMachinesGraphHelper = remoteMachinesGraphHelper;
    }

    protected abstract int runGraph(Session session, String graphFilePathToProcess) throws IOException, JSchException;

    protected abstract void execute(Session session) throws IOException, GraphException, SftpException, JSchException;

    public final void execute() throws JSchException, SftpException, IOException, GraphException {
        if (this.remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
            try {
                logger.log(Level.FINE, buildStartLogMessage());

                SSHConnection connection = new SSHConnection(this.remoteMachineCredentials.getHostName(), this.remoteMachineCredentials.getPortNumber(), this.remoteMachineCredentials.getUsername(), this.remoteMachineCredentials.getPassword());
                Session session = connection.openSesssion();
                try {
                    if (this.remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
                        execute(session);
                    }
                } finally {
                    session.disconnect();
                }
            } catch (JSchException exception) {
                if (exception.getCause() instanceof java.net.UnknownHostException || exception.getCause() instanceof java.net.ConnectException) {
                    logger.log(Level.SEVERE, buildFailedToConnectLogMessage(), exception.getMessage());
                } else {
                    throw exception;
                }
            }
        }
    }

    public void setExceptionOccurredOnRemoteMachine(Exception exception) {
        this.remoteMachinesGraphHelper.setExceptionOccurredOnRemoteMachine(exception);
    }

    protected final void runGraphs(Session session) throws IOException, GraphException, SftpException, JSchException {
        boolean canContinue = true;
        while (canContinue && this.remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
            RemoteMachineMetadata remoteMachineMetadata = this.remoteMachinesGraphHelper.computeNextGraphToRun(this.remoteMachineCredentials, this);
            if (remoteMachineMetadata == null) {
                canContinue = false;
            } else {
                boolean outputProductCreated = false;
                try {
                    String relativeFilePath = normalizePath(remoteMachineMetadata.getGraphRelativeFilePath());
                    if (relativeFilePath.charAt(0) != getFileSeparatorChar()) {
                        relativeFilePath = getFileSeparatorChar() + relativeFilePath;
                    }
                    String graphFilePathToProcess = normalizePath(this.remoteMachineCredentials.getSharedFolderPath() + relativeFilePath);

                    int exitStatus = runGraph(session, graphFilePathToProcess);
                    if (exitStatus == 0) {
                        // the graph has not been successfully executed
                        Path localSharedFolderPath = this.remoteMachinesGraphHelper.getLocalSharedFolderPath();
                        String relativePath = CloudExploitationPlatformOp.normalizePath(remoteMachineMetadata.getOutputProductRelativeFilePath());
                        Path localOutputProductFilePath = localSharedFolderPath.resolve(relativePath);
                        if (Files.exists(localOutputProductFilePath)) {
                            outputProductCreated = true;
                        }
                    } else {
                        logger.log(Level.FINE, buildLogMessage("Failed to run the graph on the remote machine. Exist status " + exitStatus+"."));
                    }
                } finally {
                    if (outputProductCreated) {
                        this.remoteMachinesGraphHelper.addOutputProductsRelativeFilePath(remoteMachineMetadata.getOutputProductRelativeFilePath());
                    } else {
                        this.remoteMachinesGraphHelper.revalidateUnprocessedGraphSourceProducts(this.remoteMachineCredentials, remoteMachineMetadata);
                    }
                }
            }
        }
    }

    protected final String buildLogMessage(String command, OutputConsoleBuffer outputConsole, int exitStatus) {
        return CloudExploitationPlatformOp.buildLogMessage(this.remoteMachineCredentials.getHostName(), command, outputConsole, exitStatus);
    }

    protected final String buildLogMessage(String message) {
        StringBuilder result = new StringBuilder();
        result.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("] ")
                .append(message);
        return result.toString();
    }

    private String buildStartLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Execute graphs on the remote machine.");
        return message.toString();
    }

    private String buildFailedToConnectLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Failed to connect to the remote machine.");
        return message.toString();
    }

    public String buildFailedLogMessage() {
        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(this.remoteMachineCredentials.getHostName())
                .append("]")
                .append(" Failed to execute the graph on the remote machine.");
        return message.toString();
    }
}
