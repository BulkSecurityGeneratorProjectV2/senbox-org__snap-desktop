package org.esa.snap.cloud.exploitation.platform;

import com.bc.ceres.binding.converters.BooleanConverter;
import com.bc.ceres.binding.converters.FileConverter;
import com.bc.ceres.binding.converters.StringConverter;
import com.bc.ceres.binding.dom.DomElement;
import com.bc.ceres.core.ProgressMonitor;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import org.apache.commons.lang.SystemUtils;
import org.esa.snap.cloud.exploitation.platform.executors.OutputConsoleBuffer;
import org.esa.snap.cloud.exploitation.platform.executors.ProcessExecutor;
import org.esa.snap.cloud.exploitation.platform.executors.SSHConnection;
import org.esa.snap.cloud.exploitation.platform.utils.NamedThreadPoolExecutor;
import org.esa.snap.cloud.exploitation.platform.utils.StringUtils;
import org.esa.snap.core.datamodel.Band;
import org.esa.snap.core.datamodel.Product;
import org.esa.snap.core.datamodel.ProductData;
import org.esa.snap.core.gpf.Operator;
import org.esa.snap.core.gpf.OperatorException;
import org.esa.snap.core.gpf.OperatorSpi;
import org.esa.snap.core.gpf.annotations.OperatorMetadata;
import org.esa.snap.core.gpf.annotations.Parameter;
import org.esa.snap.core.gpf.annotations.TargetProduct;
import org.esa.snap.core.gpf.common.ReadOp;
import org.esa.snap.core.gpf.common.WriteOp;
import org.esa.snap.core.gpf.graph.Graph;
import org.esa.snap.core.gpf.graph.Node;
import org.esa.snap.core.gpf.main.GPT;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by jcoravu on 27/12/2018.
 */
@OperatorMetadata(
        alias = "CloudExploitationPlatformOp",
        version="1.0",
        category = "Menu/Raster",
        autoWriteDisabled = true,
        description = "Execute the products on the remote machines.",
        authors = "Jean Coravu",
        copyright = "Copyright (C) 2018 by CS ROMANIA")
public class CloudExploitationPlatformOp extends Operator {

    private static final Logger logger = Logger.getLogger(CloudExploitationPlatformOp.class.getName());

    @Parameter(itemAlias = "sharedFolderURL", notNull = true, converter = StringConverter.class, description = "Specifies the shared folder URL.")
    private String masterSharedFolderURL;

    @Parameter(itemAlias = "username", notNull = true, converter = StringConverter.class, description = "Specifies the username account of the machine where the shared folder is created.")
    private String masterSharedFolderUsername;

    @Parameter(itemAlias = "password", notNull = true, converter = StringConverter.class, description = "Specifies the password account of the machine where the shared folder is created.")
    private String masterSharedFolderPassword;

    @Parameter(itemAlias = "localSharedFolderPath", notNull = false, converter = StringConverter.class, description = "Specifies the local shared folder path.")
    private String localSharedFolderPath;

    @Parameter(itemAlias = "localPassword", notNull = false, converter = StringConverter.class, description = "Specifies the password of the local machine.")
    private String localPassword;

    @Parameter(itemAlias = "slaveGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the slave graph file path to be executed on the remote machines.")
    private String slaveGraphFilePath;

    @Parameter(itemAlias = "sourceFiles", notNull = true, converter = FilesConverter.class, description = "Specifies the product files.")
    private File[] sourceProductFiles;

    @Parameter(itemAlias = "machines", notNull = true, converter = ServerCredentialsConverter.class, description = "Specifies the remote machines credentials.")
    private ServerCredentials[] remoteMachines;

    @Parameter(itemAlias = "targetGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the target graph file path.")
    private String targetGraphFilePath;

    @Parameter(itemAlias = "continueOnFailure", notNull = true, converter = BooleanConverter.class, description = "Specifies the flag to continue or not when a remote machine fails.")
    private Boolean continueOnFailure;

    @Parameter(itemAlias = "targetProductFormatName", notNull = true, converter = StringConverter.class, description = "Specifies the target product format name.")
    private String targetProductFormatName;

    @Parameter(itemAlias = "targetProductFile", notNull = true, converter = FileConverter.class, description = "Specifies the target product file path.")
    private File targetProductFile;

    @TargetProduct
    private Product targetProduct;

    public CloudExploitationPlatformOp() {
    }

    @Override
    public void initialize() throws OperatorException {
        if (StringUtils.isNullOrEmpty(this.masterSharedFolderURL)) {
            throw new OperatorInitializeException("The shared folder URL is not specified.");
        }
        if (StringUtils.isNullOrEmpty(this.masterSharedFolderUsername)) {
            throw new OperatorInitializeException("The username of the machine containing the shared folder URL is not specified.");
        }
        if (StringUtils.isNullOrEmpty(this.masterSharedFolderPassword)) {
            throw new OperatorInitializeException("The password of the machine containing the shared folder URL is not specified.");
        }
        if (this.remoteMachines == null || this.remoteMachines.length == 0) {
            throw new OperatorInitializeException("The remote machines are not specified.");
        }
        if (StringUtils.isNullOrEmpty(this.slaveGraphFilePath)) {
            throw new OperatorInitializeException("The slave graph file path is not specified.");
        }
        if (this.continueOnFailure == null) {
            throw new OperatorInitializeException("The flag to continue or not when a remote machine fails is not specified.");
        }
        if (this.sourceProductFiles == null || this.sourceProductFiles.length == 0) {
            throw new OperatorInitializeException("The source product files are not specified.");
        }
//        Path masterSharedFolderPath = Paths.get(this.masterSharedFolderURL).normalize();
//        for (int i = 0; i < this.sourceProductFiles.length; i++) {
//            Path selectedSourceProductPath = Paths.get(this.sourceProductFiles[i].getAbsolutePath()).normalize();
//            if (!selectedSourceProductPath.startsWith(masterSharedFolderPath)) {
//                throw new OperatorInitializeException("The selected source product '" + this.sourceProductFiles[i].getName() + "' does not belong to the master shared folder.");
//            }
//        }
        if (canCreateTargetProduct()) {
            if (StringUtils.isNullOrEmpty(this.targetGraphFilePath)) {
                throw new OperatorInitializeException("The target graph file path is not specified.");
            }
            if (this.targetProductFile == null) {
                throw new OperatorInitializeException("The target product file path is not specified.");
            }
            if (StringUtils.isNullOrEmpty(this.targetProductFormatName)) {
                throw new OperatorInitializeException("The target forrmat name is not specified.");
            }
        }

        int sceneRasterWidth = 200;
        int sceneRasterHeight = 200;
        this.targetProduct = new Product("CloudExploitationPlatform", "test", sceneRasterWidth, sceneRasterHeight);
        Band targetBand = new Band("band_1", ProductData.TYPE_INT32, sceneRasterWidth, sceneRasterHeight);
        this.targetProduct.addBand(targetBand);
    }

    @Override
    public void doExecute(ProgressMonitor pm) throws OperatorException {
        try {
            writeGraphsToSharedFolder();
        } catch (Exception exception) {
            throw new OperatorException("Failed to execute the operator.", exception);
        }
    }

    private boolean canCreateTargetProduct() {
        if (StringUtils.isNullOrEmpty(this.targetGraphFilePath) && this.targetProductFile == null && StringUtils.isNullOrEmpty(this.targetProductFormatName)) {
            return false;
        }
        return true;
    }

    private AbstractRemoteMachineExecutor buildRemoteMachineExecutor(ServerCredentials serverCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {
        if (serverCredentials.isLinux()) {
            return new LinuxRemoteMachineExecutor(this.masterSharedFolderUsername, this.masterSharedFolderPassword, serverCredentials, remoteMachinesGraphHelper);
        } else if (serverCredentials.isWindows()) {
            return new WindowsRemoteMachineExecutor(this.masterSharedFolderUsername, this.masterSharedFolderPassword, serverCredentials, remoteMachinesGraphHelper);
        } else {
            throw new IllegalArgumentException("The remote machine operating system is unknown '"+ serverCredentials.getOperatingSystemName()+"'.");
        }
    }

    private void writeGraphsToSharedFolder() throws Exception {
        LocalMachineLinuxMountFolder localMachineMountFolder = null;
        if (SystemUtils.IS_OS_LINUX) {
            localMachineMountFolder = CloudExploitationPlatformOp.mountLinuxLocalFolder(this.masterSharedFolderURL, this.masterSharedFolderUsername,
                                                                   this.masterSharedFolderPassword, this.localSharedFolderPath, this.localPassword);

            if (!localMachineMountFolder.isSharedFolderMounted()) {
                throw new Exception("Failed to mount the local shared folder '"+this.localSharedFolderPath+"' to the remote shared folder '"+this.masterSharedFolderURL+"'.");
            }
        }
        try {
            RemoteMachinesGraphHelper remoteMachinesGraphHelper = new RemoteMachinesGraphHelper(this.masterSharedFolderURL, this.localSharedFolderPath, this.slaveGraphFilePath,
                    this.sourceProductFiles, this.continueOnFailure.booleanValue());

            AbstractRemoteMachineExecutor firstRemoteMachineExecutor = buildRemoteMachineExecutor(this.remoteMachines[0], remoteMachinesGraphHelper);

            CountDownLatch sharedCounter = null;
            ThreadPoolExecutor threadPoolExecutor = null;
            if (this.remoteMachines.length > 1) {
                int processorCount = Runtime.getRuntime().availableProcessors();
                threadPoolExecutor = new NamedThreadPoolExecutor("cep", processorCount);

                sharedCounter = new CountDownLatch(this.remoteMachines.length - 1);
                for (int i = 1; i < this.remoteMachines.length; i++) {
                    AbstractRemoteMachineExecutor remoteMachineExecutor = buildRemoteMachineExecutor(this.remoteMachines[i], remoteMachinesGraphHelper);
                    RemoteMachineGraphExecutorRunnable runnable = new RemoteMachineGraphExecutorRunnable(remoteMachineExecutor, sharedCounter);
                    threadPoolExecutor.execute(runnable); // start the thread
                }
            }

            try {
                firstRemoteMachineExecutor.execute();
            } catch (Exception exception) {
                firstRemoteMachineExecutor.setExceptionOccurredOnRemoteMachine(exception);
                logger.log(Level.SEVERE, firstRemoteMachineExecutor.buildFailedLogMessage(), exception);
            }

            if (sharedCounter != null) {
                sharedCounter.await();
                threadPoolExecutor.shutdown();
            }

            boolean canCreate = canCreateTargetProduct();
            if (remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
                if (canCreate) {
                    logger.log(Level.FINE, "Create the target product file '"+this.targetProductFile.getAbsolutePath()+"'.");
                    Path accessibleSharedFolderPath = remoteMachinesGraphHelper.computeAccessibleSharedFolderPath();
                    processTargetGraph(accessibleSharedFolderPath, remoteMachinesGraphHelper.getOutputProductsRelativeFilePath());
                } else {
                    logger.log(Level.FINE, "The target product cannot be created because its attributes are not specified.");
                }
            } else {
                // an exception occurred on a remote machine
                if (canCreate) {
                    logger.log(Level.FINE, "The target product cannot be created because an exception occurred on a remote machine.");
                } else {
                    logger.log(Level.FINE, "An exception occurred on a remote machine.");
                }
            }
        } finally {
            if (SystemUtils.IS_OS_LINUX) {
                unmountLinuxLocalFolder(this.localSharedFolderPath, this.localPassword, localMachineMountFolder.isSharedFolderCreated());
            }
        }
    }

    private void processTargetGraph(Path accessibleSharedFolderPath, String[] outputProductsRelativeFilePath) throws Exception {
        File targetGraphFile = new File(this.targetGraphFilePath);
        Graph targetGraph = RemoteMachinesGraphHelper.readGraph(targetGraphFile);

        List<Node> readOperatorNodes = new ArrayList<Node>();
        List<Node> writeOperatorNodes = new ArrayList<Node>();
        for (int i = 0; i < targetGraph.getNodeCount(); i++) {
            Node node = targetGraph.getNode(i);
            if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(WriteOp.class))) {
                RemoteMachinesGraphHelper.configureGraphWriteNode(node);
                writeOperatorNodes.add(node);
            } else if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(ReadOp.class))) {
                RemoteMachinesGraphHelper.configureGraphReadNode(node);
                readOperatorNodes.add(node);
            }
        }
        if (writeOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain the write operator.");
        }
        if (writeOperatorNodes.size() > 1) {
            throw new IllegalStateException("The target graph must contain only one write operator. The actual number is " + writeOperatorNodes.size() + ".");
        }
        if (readOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain at least one read operator.");
        }
        if (outputProductsRelativeFilePath.length != readOperatorNodes.size()) {
            throw new IllegalStateException("The output product file count " + outputProductsRelativeFilePath.length + " is not equal with the target graph read operator count " + readOperatorNodes.size() + ".");
        }

        for (int i = 0; i < readOperatorNodes.size(); i++) {
            Node readOperatorNode = readOperatorNodes.get(i);
            String normalizedOutputProductRelativePath = CloudExploitationPlatformOp.normalizePath(outputProductsRelativeFilePath[i]);
            Path sourceProductPath = accessibleSharedFolderPath.resolve(normalizedOutputProductRelativePath);
            String sourceProductFilePathOnSharedMachine = sourceProductPath.toString();
            if (Files.exists(sourceProductPath)) {
                DomElement fileParam = readOperatorNode.getConfiguration().getChild("file");
                fileParam.setValue(sourceProductFilePathOnSharedMachine);
            } else {
                throw new IllegalStateException("The remote output product file " + sourceProductFilePathOnSharedMachine + " does not exist.");
            }
        }

        Node writeOperatorNode = writeOperatorNodes.get(0);
        DomElement fileParam = writeOperatorNode.getConfiguration().getChild("file");
        fileParam.setValue(this.targetProductFile.getAbsolutePath());
        DomElement formatNameParam = writeOperatorNode.getConfiguration().getChild("formatName");
        formatNameParam.setValue(this.targetProductFormatName);

        File targetGraphFileOnSharedMachine = accessibleSharedFolderPath.resolve(targetGraphFile.getName()).toFile();
        RemoteMachinesGraphHelper.writeGraph(targetGraph, targetGraphFileOnSharedMachine);

        String[] args = new String[] { targetGraphFileOnSharedMachine.getAbsolutePath() };
        GPT.run(args);
    }

    public File getTargetProductFile() {
        return targetProductFile;
    }

    public static boolean canConnectToRemoteMachine(ServerCredentials serverCredentials) throws JSchException {
        SSHConnection connection = new SSHConnection(serverCredentials.getHostName(), serverCredentials.getPortNumber(), serverCredentials.getUsername(), serverCredentials.getPassword());
        Session session = connection.openSesssion();
        try {
            return true;
        } finally {
            session.disconnect();
        }
    }

    public static String normalizePath(String path) {
        if (SystemUtils.IS_OS_WINDOWS) {
            return normalizeWindowsPath(path);
        } else if (SystemUtils.IS_OS_LINUX) {
            return normalizeLinuxPath(path);
        } else {
            throw new UnsupportedOperationException("Uknown operating system.");
        }
    }

    public static LocalMachineLinuxMountFolder mountLinuxLocalFolder(String remoteSharedFolderURL, String remoteUsername, String remotePassword,
                                                                     String localSharedFolderPath, String localPassword)
                                                                     throws IOException {

        String hostName = "localhost";
        String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeLinuxPath(localSharedFolderPath);

        LocalMachineLinuxMountFolder localMachineMountFolder = new LocalMachineLinuxMountFolder();
        boolean localSharedFolderExists;
        if (Files.exists(Paths.get(normalizedLocalSharedFolderPath))) {
            localSharedFolderExists = true;
        } else {
            // the local shared folder does not exist on the local disk
            String command = buildMakeFolderCommand(normalizedLocalSharedFolderPath);
            OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
            int exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

            logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));
            localSharedFolderExists = (exitStatus == 0);
            localMachineMountFolder.setSharedFolderCreated(localSharedFolderExists);
        }

        if (localSharedFolderExists) {
            String command = buildChangeFolderModeCommand(normalizedLocalSharedFolderPath);
            OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
            int exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

            logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));

            if (exitStatus == 0) {
                localMachineMountFolder.setSharedFolderChangedMode(true);
                String normalizedRemoteSharedFolderURL = CloudExploitationPlatformOp.normalizeLinuxPath(remoteSharedFolderURL);

                command = buildMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, remotePassword);
                outputConsole = new OutputConsoleBuffer();
                exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

                command = buildMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, "...");
                logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));

                if (exitStatus == 0) {
                    localMachineMountFolder.setSharedFolderMounted(true);
                }
            }
        }
        return localMachineMountFolder;
    }

    public static void unmountLinuxLocalFolder(String localSharedFolderPath, String localPassword, boolean localSharedFolderCreated)
                                               throws IOException {

        String hostName = "localhost";
        String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeLinuxPath(localSharedFolderPath);

        String command = buildUnmountSharedFolderCommand(normalizedLocalSharedFolderPath);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

        logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));

        if (localSharedFolderCreated) {
            command = buildRemoveFolderCommand(normalizedLocalSharedFolderPath);
            outputConsole = new OutputConsoleBuffer();
            exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

            logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));
        }
    }

    public static String normalizeWindowsPath(String path) {
        return path.replace('/', '\\');
    }

    public static String normalizeLinuxPath(String path) {
        return path.replace('\\', '/');
    }

    public static String buildLogMessage(String hostName, String command, OutputConsoleBuffer consoleBuffer, int exitStatus) {
        String newLineAndTab = "\n\t";
        String normalKey = "Normal: ";
        String errorKey = "Error: ";

        String emptySpaces = buildStringWithEmptySpaces(normalKey.length());
        String normalMessages = consoleBuffer.getNormalStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        emptySpaces = buildStringWithEmptySpaces(errorKey.length());
        String errorMessages = consoleBuffer.getErrorStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(hostName)
                .append("] Command: ")
                .append(command)
                .append(newLineAndTab)
                .append("Exit status: ")
                .append(exitStatus)
                .append(newLineAndTab)
                .append(normalKey)
                .append(normalMessages)
                .append(newLineAndTab)
                .append(errorKey)
                .append(errorMessages);
        return message.toString();
    }

    public static String buildUnmountSharedFolderCommand(String mountedFolderPath) {
        return "umount " + mountedFolderPath;
    }

    public static String buildRemoveFolderCommand(String folderPath) {
        return "rmdir " + folderPath;
    }

    public static String buildMakeFolderCommand(String folderPath) {
        return "mkdir " + folderPath;
    }

    public static String buildChangeFolderModeCommand(String folderPath) {
        return "chmod -R 0777 "+ folderPath;
    }

    public static String buildMountSharedFolderCommand(String remoteMachineSharedFolderURL, String localFolderPathToMount,
                                                        String remoteMachineUsername, String remoteMachinePassword) {

        StringBuilder command = new StringBuilder();
        command.append("mount.cifs")
                .append(" ")
                .append(remoteMachineSharedFolderURL)
                .append(" ")
                .append(localFolderPathToMount)
                .append(" ")
                .append("-o user=")
                .append(remoteMachineUsername)
                .append(",password=")
                .append(remoteMachinePassword)
                .append(",file_mode=0777,dir_mode=0777,noperm");
        return command.toString();
    }

    private static String buildStringWithEmptySpaces(int length) {
        StringBuilder result = new StringBuilder(length);
        for (int i=0; i<length; i++) {
            result.append(' ');
        }
        return result.toString();
    }

    private static class RemoteMachineGraphExecutorRunnable implements Runnable {

        private static final Logger logger = Logger.getLogger(RemoteMachineGraphExecutorRunnable.class.getName());

        private final AbstractRemoteMachineExecutor remoteMachineExecutor;
        private final CountDownLatch sharedCounter;

        public RemoteMachineGraphExecutorRunnable(AbstractRemoteMachineExecutor remoteMachineExecutor, CountDownLatch sharedCounter) {
            this.remoteMachineExecutor = remoteMachineExecutor;
            this.sharedCounter = sharedCounter;
        }

        @Override
        public void run() {
            try {
                this.remoteMachineExecutor.execute();
            } catch (Exception exception) {
                this.remoteMachineExecutor.setExceptionOccurredOnRemoteMachine(exception);
                logger.log(Level.SEVERE, this.remoteMachineExecutor.buildFailedLogMessage(), exception);
            } finally {
                this.sharedCounter.countDown();
            }
        }
    }

    /**
     * Collocation operator SPI.
     */
    public static class Spi extends OperatorSpi {

        public Spi() {
            super(CloudExploitationPlatformOp.class);
        }
    }
}
