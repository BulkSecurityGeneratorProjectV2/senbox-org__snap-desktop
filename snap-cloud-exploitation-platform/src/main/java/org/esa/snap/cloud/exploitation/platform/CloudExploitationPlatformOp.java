package org.esa.snap.cloud.exploitation.platform;

import com.bc.ceres.binding.converters.BooleanConverter;
import com.bc.ceres.binding.converters.StringConverter;
import com.bc.ceres.binding.dom.DomElement;
import com.bc.ceres.core.ProgressMonitor;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.thoughtworks.xstream.io.copy.HierarchicalStreamCopier;
import com.thoughtworks.xstream.io.xml.XppDomWriter;
import com.thoughtworks.xstream.io.xml.XppReader;
import com.thoughtworks.xstream.io.xml.xppdom.XppDom;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;
import org.esa.snap.cloud.exploitation.platform.executors.OutputConsoleBuffer;
import org.esa.snap.cloud.exploitation.platform.executors.ProcessExecutor;
import org.esa.snap.cloud.exploitation.platform.executors.SSHConnection;
import org.esa.snap.cloud.exploitation.platform.utils.NamedThreadPoolExecutor;
import org.esa.snap.core.datamodel.Band;
import org.esa.snap.core.datamodel.Product;
import org.esa.snap.core.datamodel.ProductData;
import org.esa.snap.core.gpf.Operator;
import org.esa.snap.core.gpf.OperatorException;
import org.esa.snap.core.gpf.OperatorSpi;
import org.esa.snap.core.gpf.annotations.OperatorMetadata;
import org.esa.snap.core.gpf.annotations.Parameter;
import org.esa.snap.core.gpf.annotations.TargetProduct;
import org.esa.snap.core.gpf.common.ReadOp;
import org.esa.snap.core.gpf.common.WriteOp;
import org.esa.snap.core.gpf.graph.Graph;
import org.esa.snap.core.gpf.graph.Node;
import org.esa.snap.core.gpf.main.GPT;
import org.esa.snap.engine_utilities.util.FileIOUtils;
import org.xmlpull.mxp1.MXParser;

import java.io.IOException;
import java.io.StringReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by jcoravu on 27/12/2018.
 */
@OperatorMetadata(
        alias = "CloudExploitationPlatformOp",
        version="1.0",
        category = "Menu/Raster",
        autoWriteDisabled = true,
        description = "Execute the products on the remote machines.",
        authors = "Jean Coravu",
        copyright = "Copyright (C) 2018 by CS ROMANIA")
public class CloudExploitationPlatformOp extends Operator {

    private static final Logger logger = Logger.getLogger(CloudExploitationPlatformOp.class.getName());

    @Parameter(itemAlias = "sharedFolderURL", notNull = true, converter = StringConverter.class, description = "Specifies the shared folder URL.")
    private String masterSharedFolderURL;

    @Parameter(itemAlias = "username", notNull = true, converter = StringConverter.class, description = "Specifies the username account of the machine where the shared folder is created.")
    private String masterSharedFolderUsername;

    @Parameter(itemAlias = "password", notNull = true, converter = StringConverter.class, description = "Specifies the password account of the machine where the shared folder is created.")
    private String masterSharedFolderPassword;

    @Parameter(itemAlias = "localSharedFolderPath", notNull = true, converter = StringConverter.class, description = "Specifies the local shared folder path.")
    private String localSharedFolderPath;

    @Parameter(itemAlias = "localPassword", notNull = false, converter = StringConverter.class, description = "Specifies the password of the local machine.")
    private String localPassword;

    @Parameter(itemAlias = "slaveGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the slave graph file path to be executed on the remote machines.")
    private String slaveGraphFilePath;

    @Parameter(itemAlias = "sourceFiles", notNull = true, converter = FilesConverter.class, description = "Specifies the product files.")
    private String[] sourceProductFiles;

    @Parameter(itemAlias = "machines", notNull = true, converter = RemoteMachineCredentialsConverter.class, description = "Specifies the remote machines credentials.")
    private RemoteMachineCredentials[] remoteMachines;

    @Parameter(itemAlias = "masterGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the master graph file path.")
    private String masterGraphFilePath;

    @Parameter(itemAlias = "continueOnFailure", notNull = true, converter = BooleanConverter.class, description = "Specifies the flag to continue or not when a remote machine fails.")
    private Boolean continueOnFailure;

    @Parameter(itemAlias = "targetProductFormatName", notNull = true, converter = StringConverter.class, description = "Specifies the target product format name.")
    private String targetProductFormatName;

    @Parameter(itemAlias = "targetProductFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the target product file path.")
    private String targetProductFilePath;

    @TargetProduct
    private Product targetProduct;

    public CloudExploitationPlatformOp() {
    }

    @Override
    public void initialize() throws OperatorException {
        if (StringUtils.isBlank(this.masterSharedFolderURL)) {
            throw new OperatorInitializeException("The master shared folder URL is not specified.");
        }
        if (SystemUtils.IS_OS_LINUX) {
            String normalizedMasterSharedFolderURL = CloudExploitationPlatformOp.normalizeLinuxPath(this.masterSharedFolderURL);
            if (!normalizedMasterSharedFolderURL.startsWith("//")) {
                throw new OperatorInitializeException("The master shared folder URL does not specifies shared folder.");
            }
        } else if (SystemUtils.IS_OS_WINDOWS) {
            String normalizedMasterSharedFolderURL = CloudExploitationPlatformOp.normalizeWindowsPath(this.masterSharedFolderURL);
            if (!normalizedMasterSharedFolderURL.startsWith("\\\\")) {
                throw new OperatorInitializeException("The master shared folder URL does not specifies shared folder.");
            }
        }
        if (StringUtils.isBlank(this.masterSharedFolderUsername)) {
            throw new OperatorInitializeException("The username of the machine containing the shared folder URL is not specified.");
        }
        if (StringUtils.isBlank(this.masterSharedFolderPassword)) {
            throw new OperatorInitializeException("The password of the machine containing the shared folder URL is not specified.");
        }
        if (this.remoteMachines == null || this.remoteMachines.length == 0) {
            throw new OperatorInitializeException("The remote machines are not specified.");
        }
        if (StringUtils.isBlank(this.slaveGraphFilePath)) {
            throw new OperatorInitializeException("The slave graph file path is not specified.");
        }
        if (this.continueOnFailure == null) {
            throw new OperatorInitializeException("The flag to continue or not when a remote machine fails is not specified.");
        }
        if (this.sourceProductFiles == null || this.sourceProductFiles.length == 0) {
            throw new OperatorInitializeException("The source product files are not specified.");
        }
        if (SystemUtils.IS_OS_LINUX) {
            if (StringUtils.isBlank(this.localSharedFolderPath)) {
                throw new OperatorInitializeException("The local shared folder path is not specified when running on Linux.");
            }
            String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeLinuxPath(this.localSharedFolderPath);
            Path path = Paths.get(normalizedLocalSharedFolderPath);
            if (!path.isAbsolute()) {
                throw new OperatorInitializeException("The local shared folder path does not represent an absolute path on Linux.");
            }
            if (StringUtils.isBlank(this.localPassword)) {
                throw new OperatorInitializeException("The local password is not specified when running on Linux.");
            }
        } else if (SystemUtils.IS_OS_WINDOWS) {
            if (!StringUtils.isBlank(this.localSharedFolderPath)) {
                char driveLetter = this.localSharedFolderPath.charAt(0);
                if (!Character.isLetter(driveLetter)) {
                    throw new IllegalArgumentException("The local shared folder path does not represent a drive when running on Windows The first character '"+driveLetter+"' is not a letter.");
                }
                String colon = this.localSharedFolderPath.substring(1);
                if (!":".equals(colon)) {
                    throw new IllegalArgumentException("Expected 'X:' for local shared driver when running on Windows.");
                }
            }
        }
        if (canCreateTargetProduct()) {
            if (StringUtils.isBlank(this.masterGraphFilePath)) {
                throw new OperatorInitializeException("The master graph file path is not specified.");
            }
            if (StringUtils.isBlank(this.targetProductFilePath)) {
                throw new OperatorInitializeException("The target product file path is not specified.");
            }
            if (StringUtils.isBlank(this.targetProductFormatName)) {
                throw new OperatorInitializeException("The target forrmat name is not specified.");
            }
        }

        int sceneRasterWidth = 1;
        int sceneRasterHeight = 1;
        this.targetProduct = new Product("CloudExploitationPlatform", "test", sceneRasterWidth, sceneRasterHeight);
        Band targetBand = new Band("band_1", ProductData.TYPE_INT32, sceneRasterWidth, sceneRasterHeight);
        this.targetProduct.addBand(targetBand);
    }

    @Override
    public void doExecute(ProgressMonitor pm) throws OperatorException {
        try {
            // mount the local shared folder
            String normalizedLocalSharedFolderPath;
            String normalizedMasterSharedFolderURL = CloudExploitationPlatformOp.normalizePath(this.masterSharedFolderURL + "/");
            LocalMachineLinuxMountFolder localMachineLinuxMountFolder = null;
            if (SystemUtils.IS_OS_LINUX) {
                localMachineLinuxMountFolder = mountLinuxLocalFolder(this.masterSharedFolderURL, this.masterSharedFolderUsername,
                                                                this.masterSharedFolderPassword, this.localSharedFolderPath, this.localPassword);
                if (!localMachineLinuxMountFolder.isSharedFolderMounted()) {
                    throw new OperatorException("Failed to mount the local shared folder '" + this.localSharedFolderPath + "' to the remote shared folder '" + this.masterSharedFolderURL + "'.");
                }
                // the local shared folder has been successfully mounted
                normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeLinuxPath(this.localSharedFolderPath + "/");
            } else if (SystemUtils.IS_OS_WINDOWS) {
                if (StringUtils.isBlank(this.localSharedFolderPath)) {
                    normalizedLocalSharedFolderPath = normalizedMasterSharedFolderURL;
                } else {
                    boolean mounted = mountWindowsLocalDrive(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, this.localSharedFolderPath);
                    if (!mounted) {
                        throw new OperatorException("Failed to mount the local drive '" + this.localSharedFolderPath + "' to the remote shared folder '" + this.masterSharedFolderURL + "'.");
                    }
                    // the local shared folder has been successfully mounted
                    normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeWindowsPath(this.localSharedFolderPath + "/");
                }
            } else {
                throw new UnsupportedOperationException("Unknown operating system.");
            }
            try {
                String[] relativeSourceProductFilePaths = new String[this.sourceProductFiles.length];
                for (int i = 0; i < this.sourceProductFiles.length; i++) {
                    String normalizedSourceProductFilePath = CloudExploitationPlatformOp.normalizePath(this.sourceProductFiles[i]);
                    String relativePath;
                    if (StringUtils.startsWithIgnoreCase(normalizedSourceProductFilePath, normalizedMasterSharedFolderURL)) {
                        relativePath = normalizedSourceProductFilePath.substring(normalizedMasterSharedFolderURL.length());
                    } else if (StringUtils.startsWithIgnoreCase(normalizedSourceProductFilePath, normalizedLocalSharedFolderPath)) {
                        relativePath = normalizedSourceProductFilePath.substring(normalizedLocalSharedFolderPath.length());
                    } else {
                        throw new OperatorException("The source product file path '"+normalizedSourceProductFilePath+"' does not start with the master shared folder url '"+normalizedMasterSharedFolderURL+"'.");
                    }
                    Path sourceFilePath = Paths.get(normalizedLocalSharedFolderPath, relativePath).normalize();
                    if (Files.exists(sourceFilePath)) {
                        relativeSourceProductFilePaths[i] = relativePath;
                    } else {
                        throw new OperatorException("The source product file '" + normalizedSourceProductFilePath + "' does not exist into the master shared folder.");
                    }
                }

                Path slaveGraphFile = checkGraphFileIfExists(normalizedMasterSharedFolderURL, normalizedLocalSharedFolderPath, this.slaveGraphFilePath, false);
                Path masterGraphFile = null;
                if (canCreateTargetProduct()) {
                    masterGraphFile = checkGraphFileIfExists(normalizedMasterSharedFolderURL, normalizedLocalSharedFolderPath, this.masterGraphFilePath, true);
                }

                writeGraphsToSharedFolder(normalizedLocalSharedFolderPath, relativeSourceProductFilePaths, slaveGraphFile, masterGraphFile);
            } finally {
                // unmount the local shared folder
                if (SystemUtils.IS_OS_LINUX) {
                    unmountLinuxLocalFolder(this.localSharedFolderPath, this.localPassword, localMachineLinuxMountFolder.isSharedFolderCreated());
                } else if (SystemUtils.IS_OS_WINDOWS) {
                    if (!StringUtils.isBlank(this.localSharedFolderPath)) {
                        unmountWindowsLocalDrive(this.localSharedFolderPath);
                    }
                }
            }
        } catch (OperatorException exception) {
            throw exception;
        } catch (Exception exception) {
            throw new OperatorException("Failed to execute the operator.", exception);
        }
    }

    private boolean canCreateTargetProduct() {
        if (StringUtils.isBlank(this.masterGraphFilePath) && StringUtils.isBlank(this.targetProductFilePath) && StringUtils.isBlank(this.targetProductFormatName)) {
            return false;
        }
        return true;
    }

    private AbstractRemoteMachineExecutor buildRemoteMachineExecutor(RemoteMachineCredentials remoteMachineCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {
        if (remoteMachineCredentials.isLinux()) {
            return new LinuxRemoteMachineExecutor(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, remoteMachineCredentials, remoteMachinesGraphHelper);
        } else if (remoteMachineCredentials.isWindows()) {
            return new WindowsRemoteMachineExecutor(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, remoteMachineCredentials, remoteMachinesGraphHelper);
        } else {
            throw new IllegalArgumentException("The remote machine operating system is unknown '"+ remoteMachineCredentials.getOperatingSystemName()+"'.");
        }
    }

    private void writeGraphsToSharedFolder(String normalizedLocalSharedFolderPath, String[] relativeSourceProductFilePaths,
                                           Path slaveGraphFile, Path masterGraphFile)
                                           throws Exception {

        Path localOutputFolderPath = Paths.get(normalizedLocalSharedFolderPath, "cloud-exploitation-platform");

        if (Files.exists(localOutputFolderPath)) {
            // delete the folder
            FileIOUtils.deleteFolder(localOutputFolderPath);
            // check if the folder still exists
            if (Files.exists(localOutputFolderPath)) {
                throw new IllegalStateException("Failed to delete the output folder path '" + localOutputFolderPath.toString()+ "' from the local shared folder.");
            }
        }
        Files.createDirectory(localOutputFolderPath);
        if (!Files.exists(localOutputFolderPath)) {
            throw new IllegalStateException("Failed to create the output folder path '" + localOutputFolderPath.toString()+ "' into the local shared folder.");
        }

        RemoteMachinesGraphHelper remoteMachinesGraphHelper = new RemoteMachinesGraphHelper(localOutputFolderPath, relativeSourceProductFilePaths, slaveGraphFile,
                                                                                            this.continueOnFailure.booleanValue());

        AbstractRemoteMachineExecutor firstRemoteMachineExecutor = buildRemoteMachineExecutor(this.remoteMachines[0], remoteMachinesGraphHelper);

        CountDownLatch sharedCounter = null;
        ThreadPoolExecutor threadPoolExecutor = null;
        if (this.remoteMachines.length > 1) {
            int processorCount = Runtime.getRuntime().availableProcessors();
            threadPoolExecutor = new NamedThreadPoolExecutor("cep", processorCount);

            sharedCounter = new CountDownLatch(this.remoteMachines.length - 1);
            for (int i = 1; i < this.remoteMachines.length; i++) {
                AbstractRemoteMachineExecutor remoteMachineExecutor = buildRemoteMachineExecutor(this.remoteMachines[i], remoteMachinesGraphHelper);
                RemoteMachineGraphExecutorRunnable runnable = new RemoteMachineGraphExecutorRunnable(remoteMachineExecutor, sharedCounter);
                threadPoolExecutor.execute(runnable); // start the thread
            }
        }

        try {
            firstRemoteMachineExecutor.execute();
        } catch (Exception exception) {
            firstRemoteMachineExecutor.setExceptionOccurredOnRemoteMachine(exception);
            logger.log(Level.SEVERE, firstRemoteMachineExecutor.buildFailedLogMessage(), exception);
        }

        if (sharedCounter != null) {
            sharedCounter.await();
            threadPoolExecutor.shutdown();
        }

        boolean canCreate = (masterGraphFile != null);
        if (remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
            // no exception occurred on the remote machines
            if (canCreate) {
                logger.log(Level.FINE, "Create the target product file '" + this.targetProductFilePath + "'.");
                processTargetGraph(localOutputFolderPath, masterGraphFile, remoteMachinesGraphHelper.getOutputProductsRelativeFilePath());
            } else {
                logger.log(Level.FINE, "The target product is not created because its attributes are not specified.");
            }
        } else {
            // an exception occurred on a remote machine
            if (canCreate) {
                logger.log(Level.FINE, "The target product cannot be created because an exception occurred on a remote machine.");
            } else {
                logger.log(Level.FINE, "An exception occurred on a remote machine.");
            }
        }
    }

    private void processTargetGraph(Path localOutputFolderPath, Path inputMasterGraphFile, String[] outputProductsRelativeFilePath) throws Exception {
        Graph masterGraph = RemoteMachinesGraphHelper.readGraph(inputMasterGraphFile);

        List<Node> readOperatorNodes = new ArrayList<Node>();
        List<Node> writeOperatorNodes = new ArrayList<Node>();
        for (int i = 0; i < masterGraph.getNodeCount(); i++) {
            Node node = masterGraph.getNode(i);
            if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(WriteOp.class))) {
                RemoteMachinesGraphHelper.configureGraphWriteNode(node);
                writeOperatorNodes.add(node);
            } else if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(ReadOp.class))) {
                RemoteMachinesGraphHelper.configureGraphReadNode(node);
                readOperatorNodes.add(node);
            }
        }
        if (writeOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain the write operator.");
        }
        if (writeOperatorNodes.size() > 1) {
            throw new IllegalStateException("The target graph must contain only one write operator. The actual number is " + writeOperatorNodes.size() + ".");
        }
        if (readOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain at least one read operator.");
        }
        if (outputProductsRelativeFilePath.length != readOperatorNodes.size()) {
            throw new IllegalStateException("The output product file count " + outputProductsRelativeFilePath.length + " is not equal with the target graph read operator count " + readOperatorNodes.size() + ".");
        }

        Path localSharedFolderPath = localOutputFolderPath.getParent();
        String masterGraphFileName = inputMasterGraphFile.getFileName().toString();

        for (int i = 0; i < readOperatorNodes.size(); i++) {
            Node readOperatorNode = readOperatorNodes.get(i);
            String normalizedOutputProductRelativePath = CloudExploitationPlatformOp.normalizePath(outputProductsRelativeFilePath[i]);
            Path sourceProductPath = localSharedFolderPath.resolve(normalizedOutputProductRelativePath);
            String sourceProductFilePathOnSharedMachine = sourceProductPath.toString();
            if (Files.exists(sourceProductPath)) {
                DomElement fileParam = readOperatorNode.getConfiguration().getChild("file");
                fileParam.setValue(sourceProductFilePathOnSharedMachine);
            } else {
                throw new IllegalStateException("The remote output product file " + sourceProductFilePathOnSharedMachine + " does not exist.");
            }
        }

        Node writeOperatorNode = writeOperatorNodes.get(0);
        DomElement fileParam = writeOperatorNode.getConfiguration().getChild("file");
        fileParam.setValue(this.targetProductFilePath);
        DomElement formatNameParam = writeOperatorNode.getConfiguration().getChild("formatName");
        formatNameParam.setValue(this.targetProductFormatName);

        Path outputMasterGraphFile = localOutputFolderPath.resolve(masterGraphFileName);
        RemoteMachinesGraphHelper.writeGraph(masterGraph, outputMasterGraphFile);

        String[] args = new String[] { outputMasterGraphFile.toString() };
        GPT.run(args);
    }

    public String getTargetProductFilePath() {
        return this.targetProductFilePath;
    }

    public static boolean canConnectToRemoteMachine(RemoteMachineCredentials serverCredentials) throws JSchException {
        SSHConnection connection = new SSHConnection(serverCredentials.getHostName(), serverCredentials.getPortNumber(), serverCredentials.getUsername(), serverCredentials.getPassword());
        Session session = connection.openSesssion();
        try {
            return true;
        } finally {
            session.disconnect();
        }
    }

    public static String normalizePath(String path) {
        if (SystemUtils.IS_OS_WINDOWS) {
            return normalizeWindowsPath(path);
        } else if (SystemUtils.IS_OS_LINUX) {
            return normalizeLinuxPath(path);
        } else {
            throw new UnsupportedOperationException("Unknown operating system.");
        }
    }

    public static boolean mountWindowsLocalDrive(String masterSharedFolderURL, String masterSharedFolderUsername,
                                                  String masterSharedFolderPassword, String localDrive)
                                                  throws IOException {

        String hostName = "localhost";

        String command = buildWindowsMountSharedDriveCommand(masterSharedFolderURL, masterSharedFolderUsername, masterSharedFolderPassword, localDrive);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeWindowsCommand(command, null, outputConsole);

        logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));
        return (exitStatus == 0);
    }

    public static boolean unmountWindowsLocalDrive(String localDrive) throws IOException {
        String hostName = "localhost";
        String command = buildWindowsUnmountSharedDriveCommand(localDrive);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeWindowsCommand(command, null, outputConsole);

        logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));
        return (exitStatus == 0);
    }

    private static Path checkGraphFileIfExists(String normalizedMasterSharedFolderURL, String normalizedLocalSharedFolderPath,
                                               String graphFilePathToCheck, boolean isMasterGraph) {

        String exceptionMessagePrefix;
        if (isMasterGraph) {
            exceptionMessagePrefix = "The master graph file '";
        } else {
            exceptionMessagePrefix = "The slave graph file '";
        }

        String normalizedGraphFilePath = CloudExploitationPlatformOp.normalizePath(graphFilePathToCheck);
        if (StringUtils.startsWithIgnoreCase(normalizedGraphFilePath, normalizedMasterSharedFolderURL)) {
            // the graph file must exists into the master shared folder
            String relativePath = normalizedGraphFilePath.substring(normalizedMasterSharedFolderURL.length());
            Path graphFilePath = Paths.get(normalizedLocalSharedFolderPath, relativePath).normalize();
            if (!Files.exists(graphFilePath)) {
                throw new OperatorException(exceptionMessagePrefix + normalizedGraphFilePath + "' does not exist into the master shared folder.");
            }
            return graphFilePath;
        }
        // the graph file must exists on the local disk
        Path graphFilePath = Paths.get(normalizedGraphFilePath).normalize();
        if (!Files.exists(graphFilePath)) {
            throw new OperatorException(exceptionMessagePrefix + normalizedGraphFilePath + "' does not exist on the local disk.");
        }
        return graphFilePath;
    }

    public static LocalMachineLinuxMountFolder mountLinuxLocalFolder(String remoteSharedFolderURL, String remoteUsername, String remotePassword,
                                                                     String localSharedFolderPath, String localPassword)
                                                                     throws IOException {

        String hostName = "localhost";
        String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeLinuxPath(localSharedFolderPath);

        LocalMachineLinuxMountFolder localMachineMountFolder = new LocalMachineLinuxMountFolder();
        boolean localSharedFolderExists;
        if (Files.exists(Paths.get(normalizedLocalSharedFolderPath))) {
            // the local shared folder already exists on the local disk
            localSharedFolderExists = true;
        } else {
            // the local shared folder does not exist on the local disk
            String command = buildLinuxMakeFolderCommand(normalizedLocalSharedFolderPath);
            OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
            int exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

            logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));
            localSharedFolderExists = (exitStatus == 0);
            localMachineMountFolder.setSharedFolderCreated(localSharedFolderExists);
        }

        if (localSharedFolderExists) {
            String command = buildLinuxChangeModeFolderCommand(normalizedLocalSharedFolderPath);
            OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
            int exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

            logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));

            if (exitStatus == 0) {
                // the changed mode command has been successfully executed on the local shared folder
                localMachineMountFolder.setSharedFolderChangedMode(true);
                String normalizedRemoteSharedFolderURL = CloudExploitationPlatformOp.normalizeLinuxPath(remoteSharedFolderURL);

                command = buildLinuxMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, remotePassword);
                outputConsole = new OutputConsoleBuffer();
                exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

                command = buildLinuxMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, "...");
                logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));

                if (exitStatus == 0) {
                    // the local shared folder has been successfully mounted
                    localMachineMountFolder.setSharedFolderMounted(true);
                } else if (localMachineMountFolder.isSharedFolderCreated()) {
                    // the local shared folder has not been mounted and remote the folder
                    deleteLinuxLocalSharedFolder(normalizedLocalSharedFolderPath, localPassword);
                }
            }
        }
        return localMachineMountFolder;
    }

    public static void unmountLinuxLocalFolder(String localSharedFolderPath, String localPassword, boolean localSharedFolderCreated)
                                               throws IOException {

        String hostName = "localhost";
        String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeLinuxPath(localSharedFolderPath);

        String command = buildUnmountLinuxSharedFolderCommand(normalizedLocalSharedFolderPath);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

        logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));

        if (localSharedFolderCreated) {
            deleteLinuxLocalSharedFolder(normalizedLocalSharedFolderPath, localPassword);
        }
    }

    private static void deleteLinuxLocalSharedFolder(String normalizedLocalSharedFolderPath, String localPassword) throws IOException {
        String hostName = "localhost";

        String command = buildLinuxRemoveFolderCommand(normalizedLocalSharedFolderPath);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeLinuxCommand(command, localPassword, null, outputConsole);

        logger.log(Level.FINE, CloudExploitationPlatformOp.buildLogMessage(hostName, command, outputConsole, exitStatus));
    }

    public static String normalizeWindowsPath(String path) {
        return path.replace('/', '\\');
    }

    public static String normalizeLinuxPath(String path) {
        return path.replace('\\', '/');
    }

    public static String buildLogMessage(String hostName, String command, OutputConsoleBuffer consoleBuffer, int exitStatus) {
        String newLineAndTab = "\n\t";
        String normalKey = "Normal: ";
        String errorKey = "Error: ";

        String emptySpaces = buildStringWithEmptySpaces(normalKey.length());
        String normalMessages = consoleBuffer.getNormalStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        emptySpaces = buildStringWithEmptySpaces(errorKey.length());
        String errorMessages = consoleBuffer.getErrorStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        StringBuilder message = new StringBuilder();
        message.append("[")
                .append(hostName)
                .append("] Command: ")
                .append(command)
                .append(newLineAndTab)
                .append("Exit status: ")
                .append(exitStatus)
                .append(newLineAndTab)
                .append(normalKey)
                .append(normalMessages)
                .append(newLineAndTab)
                .append(errorKey)
                .append(errorMessages);
        return message.toString();
    }

    public static String buildUnmountLinuxSharedFolderCommand(String mountedFolderPath) {
        return "umount " + mountedFolderPath;
    }

    public static String buildLinuxRemoveFolderCommand(String folderPath) {
        return "rmdir " + folderPath;
    }

    public static String buildLinuxMakeFolderCommand(String folderPath) {
        return "mkdir " + folderPath;
    }

    public static String buildLinuxChangeModeFolderCommand(String folderPath) {
        return "chmod -R 0777 "+ folderPath;
    }

    public static String buildLinuxMountSharedFolderCommand(String remoteMachineSharedFolderURL, String localFolderPathToMount,
                                                            String remoteMachineUsername, String remoteMachinePassword) {

        StringBuilder command = new StringBuilder();
        command.append("mount.cifs")
                .append(" ")
                .append(remoteMachineSharedFolderURL)
                .append(" ")
                .append(localFolderPathToMount)
                .append(" ")
                .append("-o user=")
                .append(remoteMachineUsername)
                .append(",password=")
                .append(remoteMachinePassword)
                .append(",file_mode=0777,dir_mode=0777,noperm");
        return command.toString();
    }

    public static String buildWindowsMountSharedDriveCommand(String masterSharedFolderURL, String masterSharedFolderUsername,
                                                             String masterSharedFolderPassword, String localDrive) {

        StringBuilder command = new StringBuilder();
        command.append("net use")
                .append(" ")
                .append(localDrive)
                .append(" ")
                .append(CloudExploitationPlatformOp.normalizeWindowsPath(masterSharedFolderURL))
                .append(" ")
                .append(masterSharedFolderPassword)
                .append(" ")
                .append("/user:")
                .append(masterSharedFolderUsername)
                .append(" ")
                .append("/persistent:no");
        return command.toString();
    }

    public static String buildWindowsUnmountSharedDriveCommand(String localDrive) {
        StringBuilder command = new StringBuilder();
        command.append("net use")
                .append(" ")
                .append(localDrive)
                .append(" ")
                .append("/delete");
        return command.toString();
    }

    private static String buildStringWithEmptySpaces(int length) {
        StringBuilder result = new StringBuilder(length);
        for (int i=0; i<length; i++) {
            result.append(' ');
        }
        return result.toString();
    }

    public static XppDom buildDom(String xml) {
        XppDomWriter domWriter = new XppDomWriter();
        new HierarchicalStreamCopier().copy(new XppReader(new StringReader(xml), new MXParser()), domWriter);
        return domWriter.getConfiguration();
    }

    private static class RemoteMachineGraphExecutorRunnable implements Runnable {

        private static final Logger logger = Logger.getLogger(RemoteMachineGraphExecutorRunnable.class.getName());

        private final AbstractRemoteMachineExecutor remoteMachineExecutor;
        private final CountDownLatch sharedCounter;

        public RemoteMachineGraphExecutorRunnable(AbstractRemoteMachineExecutor remoteMachineExecutor, CountDownLatch sharedCounter) {
            this.remoteMachineExecutor = remoteMachineExecutor;
            this.sharedCounter = sharedCounter;
        }

        @Override
        public void run() {
            try {
                this.remoteMachineExecutor.execute();
            } catch (Exception exception) {
                this.remoteMachineExecutor.setExceptionOccurredOnRemoteMachine(exception);
                logger.log(Level.SEVERE, this.remoteMachineExecutor.buildFailedLogMessage(), exception);
            } finally {
                this.sharedCounter.countDown();
            }
        }
    }

    /**
     * Collocation operator SPI.
     */
    public static class Spi extends OperatorSpi {

        public Spi() {
            super(CloudExploitationPlatformOp.class);
        }
    }
}
