package org.esa.snap.cloud.exploitation.platform;

import com.bc.ceres.binding.converters.BooleanConverter;
import com.bc.ceres.binding.converters.FileConverter;
import com.bc.ceres.binding.converters.StringConverter;
import com.bc.ceres.binding.dom.DomElement;
import com.bc.ceres.core.ProgressMonitor;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import org.esa.snap.cloud.exploitation.platform.utils.NamedThreadPoolExecutor;
import org.esa.snap.cloud.exploitation.platform.utils.StringUtils;
import org.esa.snap.core.datamodel.Band;
import org.esa.snap.core.datamodel.Product;
import org.esa.snap.core.datamodel.ProductData;
import org.esa.snap.core.gpf.Operator;
import org.esa.snap.core.gpf.OperatorException;
import org.esa.snap.core.gpf.OperatorSpi;
import org.esa.snap.core.gpf.annotations.OperatorMetadata;
import org.esa.snap.core.gpf.annotations.Parameter;
import org.esa.snap.core.gpf.annotations.TargetProduct;
import org.esa.snap.core.gpf.common.ReadOp;
import org.esa.snap.core.gpf.common.WriteOp;
import org.esa.snap.core.gpf.graph.Graph;
import org.esa.snap.core.gpf.graph.Node;
import org.esa.snap.core.gpf.main.GPT;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by jcoravu on 27/12/2018.
 */
@OperatorMetadata(
        alias = "CloudExploitationPlatformOp",
        version="1.0",
        category = "Menu/Raster",
        autoWriteDisabled = true,
        description = "Execute the products on the remote machines.",
        authors = "Jean Coravu",
        copyright = "Copyright (C) 2018 by CS ROMANIA")
public class CloudExploitationPlatformOp extends Operator {

    private static final Logger logger = Logger.getLogger(CloudExploitationPlatformOp.class.getName());

    @Parameter(itemAlias = "sharedFolderURL", notNull = true, converter = StringConverter.class, description = "Specifies the shared folder URL.")
    private String masterSharedFolderURL;

    @Parameter(itemAlias = "username", notNull = true, converter = StringConverter.class, description = "Specifies the username account of the machine where the shared folder is created.")
    private String masterSharedFolderUsername;

    @Parameter(itemAlias = "password", notNull = true, converter = StringConverter.class, description = "Specifies the password account of the machine where the shared folder is created.")
    private String masterSharedFolderPassword;

    @Parameter(itemAlias = "slaveGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the slave graph file path to be executed on the remote machines.")
    private String slaveGraphFilePath;

    @Parameter(itemAlias = "sourceFiles", notNull = true, converter = FilesConverter.class, description = "Specifies the product files.")
    private File[] sourceProductFiles;

    @Parameter(itemAlias = "machines", notNull = true, converter = ServerCredentialsConverter.class, description = "Specifies the remote machines credentials.")
    private ServerCredentials[] remoteMachines;

    @Parameter(itemAlias = "targetGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the target graph file path.")
    private String targetGraphFilePath;

    @Parameter(itemAlias = "continueOnFailure", notNull = true, converter = BooleanConverter.class, description = "Specifies the flag to continue or not when a remote machine fails.")
    private Boolean continueOnFailure;

    @Parameter(itemAlias = "targetProductFormatName", notNull = true, converter = StringConverter.class, description = "Specifies the target product format name.")
    private String targetProductFormatName;

    @Parameter(itemAlias = "targetProductFile", notNull = true, converter = FileConverter.class, description = "Specifies the target product file path.")
    private File targetProductFile;

    @TargetProduct
    private Product targetProduct;

    public CloudExploitationPlatformOp() {
    }

    @Override
    public void initialize() throws OperatorException {
        if (StringUtils.isNullOrEmpty(this.masterSharedFolderURL)) {
            throw new OperatorInitializeException("The shared folder URL is not specified.");
        }
        if (StringUtils.isNullOrEmpty(this.masterSharedFolderUsername)) {
            throw new OperatorInitializeException("The username of the machine containing the shared folder URL is not specified.");
        }
        if (StringUtils.isNullOrEmpty(this.masterSharedFolderPassword)) {
            throw new OperatorInitializeException("The password of the machine containing the shared folder URL is not specified.");
        }
        if (this.remoteMachines == null || this.remoteMachines.length == 0) {
            throw new OperatorInitializeException("The remote machines are not specified.");
        }
        if (StringUtils.isNullOrEmpty(this.slaveGraphFilePath)) {
            throw new OperatorInitializeException("The slave graph file path is not specified.");
        }
        if (this.continueOnFailure == null) {
            throw new OperatorInitializeException("The flag to continue or not when a remote machine fails is not specified.");
        }
        if (this.sourceProductFiles == null || this.sourceProductFiles.length == 0) {
            throw new OperatorInitializeException("The source product files are not specified.");
        }
        Path masterSharedFolderPath = Paths.get(this.masterSharedFolderURL).normalize();
        for (int i = 0; i < this.sourceProductFiles.length; i++) {
            Path selectedSourceProductPath = Paths.get(this.sourceProductFiles[i].getAbsolutePath()).normalize();
            if (!selectedSourceProductPath.startsWith(masterSharedFolderPath)) {
                throw new OperatorInitializeException("The selected source product '" + this.sourceProductFiles[i].getName() + "' does not belong to the master shared folder.");
            }
        }
        if (canCreateTargetProduct()) {
            if (StringUtils.isNullOrEmpty(this.targetGraphFilePath)) {
                throw new OperatorInitializeException("The target graph file path is not specified.");
            }
            if (this.targetProductFile == null) {
                throw new OperatorInitializeException("The target product file path is not specified.");
            }
            if (StringUtils.isNullOrEmpty(this.targetProductFormatName)) {
                throw new OperatorInitializeException("The target forrmat name is not specified.");
            }
        }

        int sceneRasterWidth = 200;
        int sceneRasterHeight = 200;
        this.targetProduct = new Product("CloudExploitationPlatform", "test", sceneRasterWidth, sceneRasterHeight);
        Band targetBand = new Band("band_1", ProductData.TYPE_INT32, sceneRasterWidth, sceneRasterHeight);
        this.targetProduct.addBand(targetBand);
    }

    @Override
    public void doExecute(ProgressMonitor pm) throws OperatorException {
        try {
            writeGraphsToSharedFolder();
        } catch (Exception exception) {
            throw new OperatorException("Failed to execute the operator.", exception);
        }
    }

    private boolean canCreateTargetProduct() {
        if (StringUtils.isNullOrEmpty(this.targetGraphFilePath) && this.targetProductFile == null && StringUtils.isNullOrEmpty(this.targetProductFormatName)) {
            return false;
        }
        return true;
    }

    private AbstractRemoteMachineExecutor buildRemoteMachineExecutor(ServerCredentials serverCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {
        if (serverCredentials.isLinux()) {
            return new LinuxRemoteMachineExecutor(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, serverCredentials, remoteMachinesGraphHelper);
        } else if (serverCredentials.isWindows()) {
            return new WindowsRemoteMachineExecutor(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, serverCredentials, remoteMachinesGraphHelper);
        } else {
            throw new IllegalArgumentException("The remote machine operating system is unknown '"+ serverCredentials.getOperatingSystemName()+"'.");
        }
    }

    private void writeGraphsToSharedFolder() throws Exception {
        RemoteMachinesGraphHelper remoteMachinesGraphHelper = new RemoteMachinesGraphHelper(this.masterSharedFolderURL, this.slaveGraphFilePath, this.sourceProductFiles, this.continueOnFailure.booleanValue());

        AbstractRemoteMachineExecutor firstRemoteMachineExecutor = buildRemoteMachineExecutor(this.remoteMachines[0], remoteMachinesGraphHelper);

        CountDownLatch sharedCounter = null;
        ThreadPoolExecutor threadPoolExecutor = null;
        if (this.remoteMachines.length > 1) {
            int processorCount = Runtime.getRuntime().availableProcessors();
            threadPoolExecutor = new NamedThreadPoolExecutor("cep", processorCount);

            sharedCounter = new CountDownLatch(this.remoteMachines.length - 1);
            for (int i = 1; i < this.remoteMachines.length; i++) {
                AbstractRemoteMachineExecutor remoteMachineExecutor = buildRemoteMachineExecutor(this.remoteMachines[i], remoteMachinesGraphHelper);
                RemoteMachineGraphExecutorRunnable runnable = new RemoteMachineGraphExecutorRunnable(remoteMachineExecutor, sharedCounter);
                threadPoolExecutor.execute(runnable); // start the thread
            }
        }

        try {
            firstRemoteMachineExecutor.execute();
        } catch (Exception exception) {
            firstRemoteMachineExecutor.setExceptionOccurredOnRemoteMachine(exception);
            logger.log(Level.SEVERE, firstRemoteMachineExecutor.buildFailedLogMessage(), exception);
        }

        if (sharedCounter != null) {
            sharedCounter.await();
            threadPoolExecutor.shutdown();
        }

        boolean canCreate = canCreateTargetProduct();
        if (remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
            if (canCreate) {
                logger.log(Level.FINE, "Create the target product file '"+this.targetProductFile.getAbsolutePath()+"'.");

                processTargetGraph(remoteMachinesGraphHelper.getOutputProductsRelativeFilePath());
            } else {
                logger.log(Level.FINE, "The target product cannot be created because its attributes are not specified.");
            }
        } else {
            // an exception occurred on a remote machine
            if (canCreate) {
                logger.log(Level.FINE, "The target product cannot be created because an exception occurred on a remote machine.");
            } else {
                logger.log(Level.FINE, "An exception occurred on a remote machine.");
            }
        }
    }

    private void processTargetGraph(String[] outputProductsRelativeFilePath) throws Exception {
        File targetGraphFile = new File(this.targetGraphFilePath);
        Graph targetGraph = RemoteMachinesGraphHelper.readGraph(targetGraphFile);

        List<Node> readOperatorNodes = new ArrayList<Node>();
        List<Node> writeOperatorNodes = new ArrayList<Node>();
        for (int i = 0; i < targetGraph.getNodeCount(); i++) {
            Node node = targetGraph.getNode(i);
            if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(WriteOp.class))) {
                RemoteMachinesGraphHelper.configureGraphWriteNode(node);
                writeOperatorNodes.add(node);
            } else if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(ReadOp.class))) {
                RemoteMachinesGraphHelper.configureGraphReadNode(node);
                readOperatorNodes.add(node);
            }
        }
        if (writeOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain the write operator.");
        }
        if (writeOperatorNodes.size() > 1) {
            throw new IllegalStateException("The target graph must contain only one write operator. The actual number is " + writeOperatorNodes.size() + ".");
        }
        if (readOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain at least one read operator.");
        }
        if (outputProductsRelativeFilePath.length != readOperatorNodes.size()) {
            throw new IllegalStateException("The output product file count " + outputProductsRelativeFilePath.length + " is not equal with the target graph read operator count " + readOperatorNodes.size() + ".");
        }

        for (int i = 0; i < readOperatorNodes.size(); i++) {
            Node readOperatorNode = readOperatorNodes.get(i);
            String sourceProductFilePathOnSharedMachine = this.masterSharedFolderURL + "/" + outputProductsRelativeFilePath[i];
            Path sourceProductPath = Paths.get(sourceProductFilePathOnSharedMachine);
            if (Files.exists(sourceProductPath)) {
                DomElement fileParam = readOperatorNode.getConfiguration().getChild("file");
                fileParam.setValue(sourceProductFilePathOnSharedMachine);
            } else {
                throw new IllegalStateException("The remote output product file " + sourceProductFilePathOnSharedMachine + " does not exist.");
            }
        }

        Node writeOperatorNode = writeOperatorNodes.get(0);
        DomElement fileParam = writeOperatorNode.getConfiguration().getChild("file");
        fileParam.setValue(this.targetProductFile.getAbsolutePath());
        DomElement formatNameParam = writeOperatorNode.getConfiguration().getChild("formatName");
        formatNameParam.setValue(this.targetProductFormatName);

        Path graphFolderPath = Paths.get(this.masterSharedFolderURL);
        File targetGraphFileOnSharedMachine = graphFolderPath.resolve(targetGraphFile.getName()).toFile();
        RemoteMachinesGraphHelper.writeGraph(targetGraph, targetGraphFileOnSharedMachine);

        String[] args = new String[] { targetGraphFileOnSharedMachine.getAbsolutePath() };
        GPT.run(args);
    }

    public File getTargetProductFile() {
        return targetProductFile;
    }

    public static boolean canConnectToRemoteMachine(ServerCredentials serverCredentials) throws JSchException {
        SSHConnection connection = new SSHConnection(serverCredentials.getHostName(), serverCredentials.getPortNumber(), serverCredentials.getUsername(), serverCredentials.getPassword());
        Session session = connection.openSesssion();
        try {
            return true;
        } finally {
            session.disconnect();
        }
    }

    private static class RemoteMachineGraphExecutorRunnable implements Runnable {

        private static final Logger logger = Logger.getLogger(RemoteMachineGraphExecutorRunnable.class.getName());

        private final AbstractRemoteMachineExecutor remoteMachineExecutor;
        private final CountDownLatch sharedCounter;

        public RemoteMachineGraphExecutorRunnable(AbstractRemoteMachineExecutor remoteMachineExecutor, CountDownLatch sharedCounter) {
            this.remoteMachineExecutor = remoteMachineExecutor;
            this.sharedCounter = sharedCounter;
        }

        @Override
        public void run() {
            try {
                this.remoteMachineExecutor.execute();
            } catch (Exception exception) {
                this.remoteMachineExecutor.setExceptionOccurredOnRemoteMachine(exception);
                logger.log(Level.SEVERE, this.remoteMachineExecutor.buildFailedLogMessage(), exception);
            } finally {
                this.sharedCounter.countDown();
            }
        }
    }

    /**
     * Collocation operator SPI.
     */
    public static class Spi extends OperatorSpi {

        public Spi() {
            super(CloudExploitationPlatformOp.class);
        }
    }
}
